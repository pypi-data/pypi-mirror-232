"""
Our autogenerated schemas aren't perfect. This file contains extra classes not generated by the automagic.
We also have classes in schema_overrides.py that shadow generated classes.
"""
import uuid
from enum import Enum
from typing import Any, Generic, Optional, Protocol, TypeVar

from pydantic import BaseModel, ConfigDict, Field, field_validator
from pydantic_core.core_schema import FieldValidationInfo
from typing_extensions import Self

from .generated import schemas as generated_schemas

Hyperparameter = dict[str, Any]

DataT = TypeVar("DataT")


class Response(BaseModel, Generic[DataT]):
    data: Optional[DataT] = None
    error: Optional[generated_schemas.SlingshotLogicalError] = None


class Project(Protocol):
    project_id: str
    display_name: str


class ProjectImpl(BaseModel):
    project_id: str
    display_name: str


class HasRunId(Protocol):
    run_id: str


class HasExecutionEnvironmentSpecId(Protocol):
    execution_environment_spec_id: str


class HasExecutionEnvironmentId(Protocol):
    execution_environment_id: str


class HasComponentSpecId(Protocol):
    spec_id: str


class HasSourceCodeId(Protocol):
    source_code_id: str
    source_code_name: str


class HasBlobArtifactId(Protocol):
    blob_artifact_id: str


class AppInstanceStatus(str, Enum):
    STOPPED = "STOPPED"
    STARTING = "STARTING"
    READY = "READY"
    ERROR = "ERROR"


class JobStatus(str, Enum):
    NEW = "NEW"
    ACTIVE = "ACTIVE"
    SUCCESS = "SUCCESS"
    CANCELLING = "CANCELLING"
    CANCELLED = "CANCELLED"
    ERROR = "ERROR"


class AuthTokenUnion(BaseModel):
    token: str
    user_id: Optional[str] = None
    service_account_id: Optional[str] = None

    @classmethod
    def from_auth_token(cls, auth_token: generated_schemas.AuthToken) -> Self:
        return cls(token=auth_token.token, user_id=auth_token.user_id, service_account_id=None)

    @classmethod
    def from_service_account_token(cls, service_account_token: generated_schemas.ServiceAccountToken) -> Self:
        return cls(
            token=service_account_token.token, user_id=None, service_account_id=service_account_token.service_account_id
        )

    @property
    def is_service_account(self) -> bool:
        return self.service_account_id is not None

    @property
    def is_user(self) -> bool:
        return self.user_id is not None

    @field_validator("service_account_id")
    def validate_xor(cls, v: str | None, info: FieldValidationInfo) -> str | None:
        if v is None and info.data.get("user_id") is None:
            raise ValueError("Both service_account_id and user_id cannot be None")
        if v is not None and info.data.get("user_id") is not None:
            raise ValueError("Both service_account_id and user_id cannot be set")
        return v


# Note: these are copied from the backend schemas, but should ideally be generated from those.
class Result(BaseModel):
    model_config = ConfigDict(extra='allow', populate_by_name=True)


class ExampleResult(BaseModel):
    example_id: str = Field(default_factory=lambda: uuid.uuid4().hex[:8], alias="exampleId")
    result: Result = Field(..., description="Result for the given example")
    model_config = ConfigDict(populate_by_name=True)


class Example(BaseModel):
    example_id: str = Field(default_factory=lambda: uuid.uuid4().hex[:8], alias="exampleId")
    data: Any = Field(..., description="Data for the given example")
    model_config = ConfigDict(populate_by_name=True, extra="allow")
