import { SvelteComponentDev, init, safe_not_equal, dispatch_dev, validate_slots, element, text, space, attr_dev, add_location, insert_dev, append_dev, set_data_dev, noop, detach_dev } from '../../../node/dev/svelte-internal.js';
import './Button-4caa11f6.js';

/* home/runner/work/gradio/gradio/js/atoms/src/UploadText.svelte generated by Svelte v4.0.0 */

const file = "home/runner/work/gradio/gradio/js/atoms/src/UploadText.svelte";

function create_fragment(ctx) {
	let div;
	let t0_value = /*i18n*/ ctx[1](/*defs*/ ctx[2][/*type*/ ctx[0]]) + "";
	let t0;
	let t1;
	let span;
	let t2;
	let t3_value = /*i18n*/ ctx[1]("common.or") + "";
	let t3;
	let t4;
	let t5;
	let t6_value = /*i18n*/ ctx[1]("upload_text.click_to_upload") + "";
	let t6;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			span = element("span");
			t2 = text("- ");
			t3 = text(t3_value);
			t4 = text(" -");
			t5 = space();
			t6 = text(t6_value);
			attr_dev(span, "class", "or s-CAl5XdcTblRW");
			add_location(span, file, 17, 1, 308);
			attr_dev(div, "class", "wrap s-CAl5XdcTblRW");
			add_location(div, file, 15, 0, 268);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t0);
			append_dev(div, t1);
			append_dev(div, span);
			append_dev(span, t2);
			append_dev(span, t3);
			append_dev(span, t4);
			append_dev(div, t5);
			append_dev(div, t6);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*i18n, type*/ 3 && t0_value !== (t0_value = /*i18n*/ ctx[1](/*defs*/ ctx[2][/*type*/ ctx[0]]) + "")) set_data_dev(t0, t0_value);
			if (dirty & /*i18n*/ 2 && t3_value !== (t3_value = /*i18n*/ ctx[1]("common.or") + "")) set_data_dev(t3, t3_value);
			if (dirty & /*i18n*/ 2 && t6_value !== (t6_value = /*i18n*/ ctx[1]("upload_text.click_to_upload") + "")) set_data_dev(t6, t6_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(div);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('UploadText', slots, []);
	let { type = "file" } = $$props;
	let { i18n } = $$props;

	const defs = {
		image: "upload_text.drop_image",
		video: "upload_text.drop_video",
		audio: "upload_text.drop_audio",
		file: "upload_text.drop_file",
		csv: "upload_text.drop_csv"
	};

	$$self.$$.on_mount.push(function () {
		if (i18n === undefined && !('i18n' in $$props || $$self.$$.bound[$$self.$$.props['i18n']])) {
			console.warn("<UploadText> was created without expected prop 'i18n'");
		}
	});

	const writable_props = ['type', 'i18n'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UploadText> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('i18n' in $$props) $$invalidate(1, i18n = $$props.i18n);
	};

	$$self.$capture_state = () => ({ type, i18n, defs });

	$$self.$inject_state = $$props => {
		if ('type' in $$props) $$invalidate(0, type = $$props.type);
		if ('i18n' in $$props) $$invalidate(1, i18n = $$props.i18n);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [type, i18n, defs];
}

class UploadText extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { type: 0, i18n: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UploadText",
			options,
			id: create_fragment.name
		});
	}

	get type() {
		throw new Error("<UploadText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<UploadText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get i18n() {
		throw new Error("<UploadText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set i18n(value) {
		throw new Error("<UploadText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { UploadText as U };
//# sourceMappingURL=UploadText-f1f8051d.js.map
