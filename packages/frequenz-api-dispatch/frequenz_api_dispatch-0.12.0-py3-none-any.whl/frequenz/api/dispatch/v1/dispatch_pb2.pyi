"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Frequenz Dispatch Automation API

Overview:
The API serves to automate the process of electricity dispatches for microgrids.
In the context of the energy industry, a 'dispatch' refers to the act of routing electrical power
between different components within a microgrid or between a microgrid and the main grid.
This could be for the purpose of supply (sending electricity to the grid or components within the microgrid),
or demand (drawing electricity from the grid or from other components like batteries and solar arrays).

Objective:
The primary objective of this API is to streamline and automate the complex task of electricity dispatching,
making it easier to manage local electricity supply and demand efficiently.

Key Features:
- Dispatching Electricity: Comprehensive CRUD operations for dispatching microgrid components.
- Automation: Support for one-time as well as recurring dispatches based on flexible recurrence rules.
- Fine-grained control: Dispatch individual microgrid components or entire component categories.

Example Use Cases:
- Charging or discharging a battery based on optimal time-of-use rates.
- Limiting the output of a Photovoltaic (PV) array during periods of low demand.
- Invoking Frequency Containment Reserves (FCR) or Automatic Frequency Restoration Reserves (aFRR) to
   support grid operations.
- Adjusting the output of electric vehicle charging stations to match grid availability or to avoid peak pricing.

Target Audience:
This API is designed for application developers in the energy sector who focus on the tasks of optimizing microgrid
electricity flows. Its design aims to be as developer-friendly as possible, requiring no prior knowledge in
electrical engineering and systems.

Copyright:
Copyright 2022 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""
import builtins
import collections.abc
import frequenz.api.common.components_pb2
import google.protobuf.descriptor
import google.protobuf.field_mask_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing_extensions.final
class Dispatch(google.protobuf.message.Message):
    """Message representing one dispatch.

    Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC
    to its local timezone.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    MICROGRID_ID_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    CREATE_TIME_FIELD_NUMBER: builtins.int
    UPDATE_TIME_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    DURATION_FIELD_NUMBER: builtins.int
    SELECTOR_FIELD_NUMBER: builtins.int
    IS_ACTIVE_FIELD_NUMBER: builtins.int
    IS_DRY_RUN_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    RECURRENCE_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The dispatch identifier"""
    microgrid_id: builtins.int
    """The microgrid identifier"""
    type: builtins.str
    """The dispatch type.
    Contains user-defined information about what "type" of dispatch this is.
    Downstream applications that consume the dispatch API are responsible for
    understanding and processing this field.
    """
    @property
    def create_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The creation time in UTC
        This is set when a dispatch is created via the create request message
        """
    @property
    def update_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The update time in UTC
        This is set when a dispatch is modified via the update request message
        """
    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The start time in UTC"""
    duration: builtins.int
    """Duration in seconds"""
    @property
    def selector(self) -> global___ComponentSelector:
        """The component selector"""
    is_active: builtins.bool
    """The "active" status
    An active dispatch is eligible for processing, either immediately or at a scheduled
    time in the future, including recurring dispatches. If a dispatch is set to
    inactive, it won't be processed even if it matches all other conditions, allowing
    for temporary disabling of dispatches without deletion.
    """
    is_dry_run: builtins.bool
    """The "dry run" status
    A dry run dispatch is executed for logging and monitoring purposes
    without affecting the microgrid components. This is useful, for example,
    in scenarios where a user may want to test dispatch behavior without
    actually affecting any component states.
    Notably, a dispatch can be both "dry run" and "active," allowing for
    the system to generate logs and observe behavior without making actual changes.
    """
    @property
    def payload(self) -> google.protobuf.struct_pb2.Struct:
        """The dispatch payload"""
    @property
    def recurrence(self) -> global___RecurrenceRule:
        """The recurrence rule"""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        microgrid_id: builtins.int = ...,
        type: builtins.str = ...,
        create_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        update_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        duration: builtins.int = ...,
        selector: global___ComponentSelector | None = ...,
        is_active: builtins.bool = ...,
        is_dry_run: builtins.bool = ...,
        payload: google.protobuf.struct_pb2.Struct | None = ...,
        recurrence: global___RecurrenceRule | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["create_time", b"create_time", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "update_time", b"update_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["create_time", b"create_time", "duration", b"duration", "id", b"id", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "microgrid_id", b"microgrid_id", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "type", b"type", "update_time", b"update_time"]) -> None: ...

global___Dispatch = Dispatch

@typing_extensions.final
class TimeIntervalFilter(google.protobuf.message.Message):
    """Filter parameter for specifying multiple time intervals"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_FROM_FIELD_NUMBER: builtins.int
    START_TO_FIELD_NUMBER: builtins.int
    END_FROM_FIELD_NUMBER: builtins.int
    END_TO_FIELD_NUMBER: builtins.int
    @property
    def start_from(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Filter by start_time >= this timestamp"""
    @property
    def start_to(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Filter by start_time < this timestamp"""
    @property
    def end_from(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Filter by recurrence.end_time >= this timestamp"""
    @property
    def end_to(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Filter by recurrence.end_time < this timestamp"""
    def __init__(
        self,
        *,
        start_from: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        start_to: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        end_from: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        end_to: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_from", b"end_from", "end_to", b"end_to", "start_from", b"start_from", "start_to", b"start_to"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["end_from", b"end_from", "end_to", b"end_to", "start_from", b"start_from", "start_to", b"start_to"]) -> None: ...

global___TimeIntervalFilter = TimeIntervalFilter

@typing_extensions.final
class ComponentSelector(google.protobuf.message.Message):
    """Parameter for controlling which components a dispatch applies to
    Either a set of component IDs, or all components belonging to a category
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPONENT_IDS_FIELD_NUMBER: builtins.int
    COMPONENT_CATEGORY_FIELD_NUMBER: builtins.int
    @property
    def component_ids(self) -> global___ComponentIDs:
        """Set of component IDs"""
    component_category: frequenz.api.common.components_pb2.ComponentCategory.ValueType
    """Component category"""
    def __init__(
        self,
        *,
        component_ids: global___ComponentIDs | None = ...,
        component_category: frequenz.api.common.components_pb2.ComponentCategory.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["component_category", b"component_category", "component_ids", b"component_ids", "selector", b"selector"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["component_category", b"component_category", "component_ids", b"component_ids", "selector", b"selector"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["selector", b"selector"]) -> typing_extensions.Literal["component_ids", "component_category"] | None: ...

global___ComponentSelector = ComponentSelector

@typing_extensions.final
class ComponentIDs(google.protobuf.message.Message):
    """Wrapper for controlling dispatches with a set of component IDs"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COMPONENT_IDS_FIELD_NUMBER: builtins.int
    @property
    def component_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Set of component IDs"""
    def __init__(
        self,
        *,
        component_ids: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["component_ids", b"component_ids"]) -> None: ...

global___ComponentIDs = ComponentIDs

@typing_extensions.final
class RecurrenceRule(google.protobuf.message.Message):
    """Ruleset governing when and how a dispatch should re-occur.

    Timezone Note: Timestamps are in UTC. It is the responsibility of each microgrid to translate UTC
    to its local timezone.

    This definition tries to adhere closely to the iCalendar specification (RFC 5545),
    particularly for recurrence rules. For advanced use-cases or further clarifications,
    refer to RFC 5545.

    Examples:

    Every 6 months:
    ```
    message RecurrenceRule {
      Frequency freq = FREQUENCY_MONTHLY;
      uint32 interval = 6;
    }
    ```

    Weekends only:
    ```
    message RecurrenceRule {
      Frequency freq = FREQUENCY_WEEKLY;
      repeated Weekday byweekdays = [WEEKDAY_SATURDAY, WEEKDAY_SUNDAY];
    }
    ```

    Every day at midnight:
    ```
    message RecurrenceRule {
      Frequency freq = FREQUENCY_DAILY;
      repeated uint32 byhours = [0];
    }
    ```

    Nightly, assuming "night" means from 8 PM to 6 AM:
    ```
    message RecurrenceRule {
      Frequency freq = FREQUENCY_DAILY;
      repeated uint32 byhours = [20, 21, 22, 23, 0, 1, 2, 3, 4, 5];
    }
    ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _Weekday:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _WeekdayEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RecurrenceRule._Weekday.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        WEEKDAY_UNSPECIFIED: RecurrenceRule._Weekday.ValueType  # 0
        WEEKDAY_MONDAY: RecurrenceRule._Weekday.ValueType  # 1
        WEEKDAY_TUESDAY: RecurrenceRule._Weekday.ValueType  # 2
        WEEKDAY_WEDNESDAY: RecurrenceRule._Weekday.ValueType  # 3
        WEEKDAY_THURSDAY: RecurrenceRule._Weekday.ValueType  # 4
        WEEKDAY_FRIDAY: RecurrenceRule._Weekday.ValueType  # 5
        WEEKDAY_SATURDAY: RecurrenceRule._Weekday.ValueType  # 6
        WEEKDAY_SUNDAY: RecurrenceRule._Weekday.ValueType  # 7

    class Weekday(_Weekday, metaclass=_WeekdayEnumTypeWrapper):
        """Enum representing the day of the week"""

    WEEKDAY_UNSPECIFIED: RecurrenceRule.Weekday.ValueType  # 0
    WEEKDAY_MONDAY: RecurrenceRule.Weekday.ValueType  # 1
    WEEKDAY_TUESDAY: RecurrenceRule.Weekday.ValueType  # 2
    WEEKDAY_WEDNESDAY: RecurrenceRule.Weekday.ValueType  # 3
    WEEKDAY_THURSDAY: RecurrenceRule.Weekday.ValueType  # 4
    WEEKDAY_FRIDAY: RecurrenceRule.Weekday.ValueType  # 5
    WEEKDAY_SATURDAY: RecurrenceRule.Weekday.ValueType  # 6
    WEEKDAY_SUNDAY: RecurrenceRule.Weekday.ValueType  # 7

    class _Frequency:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _FrequencyEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[RecurrenceRule._Frequency.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        FREQUENCY_UNSPECIFIED: RecurrenceRule._Frequency.ValueType  # 0
        FREQUENCY_MINUTELY: RecurrenceRule._Frequency.ValueType  # 1
        FREQUENCY_HOURLY: RecurrenceRule._Frequency.ValueType  # 2
        FREQUENCY_DAILY: RecurrenceRule._Frequency.ValueType  # 3
        FREQUENCY_WEEKLY: RecurrenceRule._Frequency.ValueType  # 4
        FREQUENCY_MONTHLY: RecurrenceRule._Frequency.ValueType  # 5

    class Frequency(_Frequency, metaclass=_FrequencyEnumTypeWrapper):
        """Enum representing the frequency of the recurrence"""

    FREQUENCY_UNSPECIFIED: RecurrenceRule.Frequency.ValueType  # 0
    FREQUENCY_MINUTELY: RecurrenceRule.Frequency.ValueType  # 1
    FREQUENCY_HOURLY: RecurrenceRule.Frequency.ValueType  # 2
    FREQUENCY_DAILY: RecurrenceRule.Frequency.ValueType  # 3
    FREQUENCY_WEEKLY: RecurrenceRule.Frequency.ValueType  # 4
    FREQUENCY_MONTHLY: RecurrenceRule.Frequency.ValueType  # 5

    @typing_extensions.final
    class EndCriteria(google.protobuf.message.Message):
        """Controls when a recurring dispatch should end"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        COUNT_FIELD_NUMBER: builtins.int
        UNTIL_FIELD_NUMBER: builtins.int
        count: builtins.int
        """The number of times this dispatch should recur.
        If this field is set, the dispatch will recur the given number of times.
        """
        @property
        def until(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The end time of this dispatch in UTC.
            If this field is set, the dispatch will recur until the given timestamp.
            """
        def __init__(
            self,
            *,
            count: builtins.int = ...,
            until: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["count", b"count", "count_or_until", b"count_or_until", "until", b"until"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["count", b"count", "count_or_until", b"count_or_until", "until", b"until"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["count_or_until", b"count_or_until"]) -> typing_extensions.Literal["count", "until"] | None: ...

    FREQ_FIELD_NUMBER: builtins.int
    INTERVAL_FIELD_NUMBER: builtins.int
    END_CRITERIA_FIELD_NUMBER: builtins.int
    BYMINUTES_FIELD_NUMBER: builtins.int
    BYHOURS_FIELD_NUMBER: builtins.int
    BYWEEKDAYS_FIELD_NUMBER: builtins.int
    BYMONTHDAYS_FIELD_NUMBER: builtins.int
    BYMONTHS_FIELD_NUMBER: builtins.int
    freq: global___RecurrenceRule.Frequency.ValueType
    """The frequency specifier of this recurring dispatch"""
    interval: builtins.int
    """How often this dispatch should recur, based on the frequency
    Example:
    - Every 2 hours:
      freq = FREQUENCY_HOURLY
      interval = 2
    """
    @property
    def end_criteria(self) -> global___RecurrenceRule.EndCriteria:
        """When this dispatch should end.
        A dispatch can either recur a fixed number of times, or until a given timestamp.
        If this field is not set, the dispatch will recur indefinitely.bool
        """
    @property
    def byminutes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which minute(s) of the hour does the event occur"""
    @property
    def byhours(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which hour(s) of the day does the event occur"""
    @property
    def byweekdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___RecurrenceRule.Weekday.ValueType]:
        """On which day(s) of the week does the event occur"""
    @property
    def bymonthdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which day(s) of the month does the event occur"""
    @property
    def bymonths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """On which month(s) of the year does the event occur"""
    def __init__(
        self,
        *,
        freq: global___RecurrenceRule.Frequency.ValueType = ...,
        interval: builtins.int = ...,
        end_criteria: global___RecurrenceRule.EndCriteria | None = ...,
        byminutes: collections.abc.Iterable[builtins.int] | None = ...,
        byhours: collections.abc.Iterable[builtins.int] | None = ...,
        byweekdays: collections.abc.Iterable[global___RecurrenceRule.Weekday.ValueType] | None = ...,
        bymonthdays: collections.abc.Iterable[builtins.int] | None = ...,
        bymonths: collections.abc.Iterable[builtins.int] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["end_criteria", b"end_criteria"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["byhours", b"byhours", "byminutes", b"byminutes", "bymonthdays", b"bymonthdays", "bymonths", b"bymonths", "byweekdays", b"byweekdays", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> None: ...

global___RecurrenceRule = RecurrenceRule

@typing_extensions.final
class DispatchListRequest(google.protobuf.message.Message):
    """Message for listing dispatches for a given microgrid, and an optional filter"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid ID"""
    @property
    def filter(self) -> global___DispatchFilter:
        """Additional filter parameters"""
    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        filter: global___DispatchFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["filter", b"filter", "microgrid_id", b"microgrid_id"]) -> None: ...

global___DispatchListRequest = DispatchListRequest

@typing_extensions.final
class DispatchFilter(google.protobuf.message.Message):
    """Parameters for filtering the dispatch list"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SELECTORS_FIELD_NUMBER: builtins.int
    TIME_INTERVAL_FIELD_NUMBER: builtins.int
    IS_ACTIVE_FIELD_NUMBER: builtins.int
    IS_DRY_RUN_FIELD_NUMBER: builtins.int
    @property
    def selectors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ComponentSelector]:
        """Filter by component ID or category"""
    @property
    def time_interval(self) -> global___TimeIntervalFilter:
        """Filter by time interval
        If no interval is provided, all dispatches starting from the
        current timestamp will be included.
        """
    is_active: builtins.bool
    """Filter by active status
    If this field is not set, dispatches of any active status will be included.
    """
    is_dry_run: builtins.bool
    """Filter by dry run status
    If this field is not set, dispatches of any dry run status will be included.
    """
    def __init__(
        self,
        *,
        selectors: collections.abc.Iterable[global___ComponentSelector] | None = ...,
        time_interval: global___TimeIntervalFilter | None = ...,
        is_active: builtins.bool | None = ...,
        is_dry_run: builtins.bool | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "time_interval", b"time_interval"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "selectors", b"selectors", "time_interval", b"time_interval"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_is_active", b"_is_active"]) -> typing_extensions.Literal["is_active"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_is_dry_run", b"_is_dry_run"]) -> typing_extensions.Literal["is_dry_run"] | None: ...

global___DispatchFilter = DispatchFilter

@typing_extensions.final
class DispatchList(google.protobuf.message.Message):
    """A list of dispatches"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DISPATCHES_FIELD_NUMBER: builtins.int
    @property
    def dispatches(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Dispatch]:
        """The dispatches"""
    def __init__(
        self,
        *,
        dispatches: collections.abc.Iterable[global___Dispatch] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["dispatches", b"dispatches"]) -> None: ...

global___DispatchList = DispatchList

@typing_extensions.final
class DispatchCreateRequest(google.protobuf.message.Message):
    """Message to create a new dispatch with the given attributes"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    START_TIME_FIELD_NUMBER: builtins.int
    DURATION_FIELD_NUMBER: builtins.int
    SELECTOR_FIELD_NUMBER: builtins.int
    IS_ACTIVE_FIELD_NUMBER: builtins.int
    IS_DRY_RUN_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    RECURRENCE_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """The microgrid identifier"""
    type: builtins.str
    """The type of dispatch"""
    @property
    def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The start time
        When creating a dispatch, ensure that the starting timestamp is set to
        the current time or any future time.
        Timestamps earlier than the current time are not allowed.
        """
    duration: builtins.int
    """Duration in seconds"""
    @property
    def selector(self) -> global___ComponentSelector:
        """The component selector"""
    is_active: builtins.bool
    """The "active" status"""
    is_dry_run: builtins.bool
    """The "dry run" status"""
    @property
    def payload(self) -> google.protobuf.struct_pb2.Struct:
        """The dispatch payload"""
    @property
    def recurrence(self) -> global___RecurrenceRule:
        """The recurrence rule"""
    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        type: builtins.str = ...,
        start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        duration: builtins.int = ...,
        selector: global___ComponentSelector | None = ...,
        is_active: builtins.bool = ...,
        is_dry_run: builtins.bool = ...,
        payload: google.protobuf.struct_pb2.Struct | None = ...,
        recurrence: global___RecurrenceRule | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["duration", b"duration", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "microgrid_id", b"microgrid_id", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "type", b"type"]) -> None: ...

global___DispatchCreateRequest = DispatchCreateRequest

@typing_extensions.final
class DispatchUpdateRequest(google.protobuf.message.Message):
    """Message to update the dispatch with the given ID, with the given attributes"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing_extensions.final
    class DispatchUpdate(google.protobuf.message.Message):
        """Message containing the updated dispatch attributes"""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        @typing_extensions.final
        class RecurrenceRuleUpdate(google.protobuf.message.Message):
            """Message containing the updated recurrence rule attributes"""

            DESCRIPTOR: google.protobuf.descriptor.Descriptor

            FREQ_FIELD_NUMBER: builtins.int
            INTERVAL_FIELD_NUMBER: builtins.int
            END_CRITERIA_FIELD_NUMBER: builtins.int
            BYMINUTES_FIELD_NUMBER: builtins.int
            BYHOURS_FIELD_NUMBER: builtins.int
            BYWEEKDAYS_FIELD_NUMBER: builtins.int
            BYMONTHDAYS_FIELD_NUMBER: builtins.int
            BYMONTHS_FIELD_NUMBER: builtins.int
            freq: global___RecurrenceRule.Frequency.ValueType
            """The frequency specifier of this recurring dispatch"""
            interval: builtins.int
            """How often this dispatch should recur, based on the frequency"""
            @property
            def end_criteria(self) -> global___RecurrenceRule.EndCriteria:
                """When this dispatch should end."""
            @property
            def byminutes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which minute(s) of the hour does the event occur"""
            @property
            def byhours(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which hour(s) of the day does the event occur"""
            @property
            def byweekdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___RecurrenceRule.Weekday.ValueType]:
                """On which day(s) of the week does the event occur"""
            @property
            def bymonthdays(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which day(s) of the month does the event occur"""
            @property
            def bymonths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
                """On which month(s) of the year does the event occur"""
            def __init__(
                self,
                *,
                freq: global___RecurrenceRule.Frequency.ValueType | None = ...,
                interval: builtins.int | None = ...,
                end_criteria: global___RecurrenceRule.EndCriteria | None = ...,
                byminutes: collections.abc.Iterable[builtins.int] | None = ...,
                byhours: collections.abc.Iterable[builtins.int] | None = ...,
                byweekdays: collections.abc.Iterable[global___RecurrenceRule.Weekday.ValueType] | None = ...,
                bymonthdays: collections.abc.Iterable[builtins.int] | None = ...,
                bymonths: collections.abc.Iterable[builtins.int] | None = ...,
            ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["_freq", b"_freq", "_interval", b"_interval", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["_freq", b"_freq", "_interval", b"_interval", "byhours", b"byhours", "byminutes", b"byminutes", "bymonthdays", b"bymonthdays", "bymonths", b"bymonths", "byweekdays", b"byweekdays", "end_criteria", b"end_criteria", "freq", b"freq", "interval", b"interval"]) -> None: ...
            @typing.overload
            def WhichOneof(self, oneof_group: typing_extensions.Literal["_freq", b"_freq"]) -> typing_extensions.Literal["freq"] | None: ...
            @typing.overload
            def WhichOneof(self, oneof_group: typing_extensions.Literal["_interval", b"_interval"]) -> typing_extensions.Literal["interval"] | None: ...

        TYPE_FIELD_NUMBER: builtins.int
        START_TIME_FIELD_NUMBER: builtins.int
        DURATION_FIELD_NUMBER: builtins.int
        SELECTOR_FIELD_NUMBER: builtins.int
        IS_ACTIVE_FIELD_NUMBER: builtins.int
        IS_DRY_RUN_FIELD_NUMBER: builtins.int
        PAYLOAD_FIELD_NUMBER: builtins.int
        RECURRENCE_FIELD_NUMBER: builtins.int
        type: builtins.str
        """The type of dispatch"""
        @property
        def start_time(self) -> google.protobuf.timestamp_pb2.Timestamp:
            """The start time
            When updating a dispatch, ensure that the starting timestamp is set to
            the current time or any future time.
            Timestamps earlier than the current time are not allowed.
            """
        duration: builtins.int
        """Duration in seconds"""
        @property
        def selector(self) -> global___ComponentSelector:
            """The component selector"""
        is_active: builtins.bool
        """The "active" status"""
        is_dry_run: builtins.bool
        """The "dry run" status"""
        @property
        def payload(self) -> google.protobuf.struct_pb2.Struct:
            """The dispatch payload"""
        @property
        def recurrence(self) -> global___DispatchUpdateRequest.DispatchUpdate.RecurrenceRuleUpdate:
            """The recurrence rule"""
        def __init__(
            self,
            *,
            type: builtins.str | None = ...,
            start_time: google.protobuf.timestamp_pb2.Timestamp | None = ...,
            duration: builtins.int | None = ...,
            selector: global___ComponentSelector | None = ...,
            is_active: builtins.bool | None = ...,
            is_dry_run: builtins.bool | None = ...,
            payload: google.protobuf.struct_pb2.Struct | None = ...,
            recurrence: global___DispatchUpdateRequest.DispatchUpdate.RecurrenceRuleUpdate | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["_duration", b"_duration", "_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "_type", b"_type", "duration", b"duration", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "type", b"type"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["_duration", b"_duration", "_is_active", b"_is_active", "_is_dry_run", b"_is_dry_run", "_type", b"_type", "duration", b"duration", "is_active", b"is_active", "is_dry_run", b"is_dry_run", "payload", b"payload", "recurrence", b"recurrence", "selector", b"selector", "start_time", b"start_time", "type", b"type"]) -> None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_duration", b"_duration"]) -> typing_extensions.Literal["duration"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_is_active", b"_is_active"]) -> typing_extensions.Literal["is_active"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_is_dry_run", b"_is_dry_run"]) -> typing_extensions.Literal["is_dry_run"] | None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_type", b"_type"]) -> typing_extensions.Literal["type"] | None: ...

    ID_FIELD_NUMBER: builtins.int
    UPDATE_MASK_FIELD_NUMBER: builtins.int
    UPDATE_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The dispatch identifier"""
    @property
    def update_mask(self) -> google.protobuf.field_mask_pb2.FieldMask:
        """Field mask specifying which fields should be updated"""
    @property
    def update(self) -> global___DispatchUpdateRequest.DispatchUpdate:
        """The updated dispatch attributes"""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
        update_mask: google.protobuf.field_mask_pb2.FieldMask | None = ...,
        update: global___DispatchUpdateRequest.DispatchUpdate | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["update", b"update", "update_mask", b"update_mask"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id", "update", b"update", "update_mask", b"update_mask"]) -> None: ...

global___DispatchUpdateRequest = DispatchUpdateRequest

@typing_extensions.final
class DispatchGetRequest(google.protobuf.message.Message):
    """Message to get a single dispatch by its ID"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The dispatch identifier"""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id"]) -> None: ...

global___DispatchGetRequest = DispatchGetRequest

@typing_extensions.final
class DispatchDeleteRequest(google.protobuf.message.Message):
    """Message to delete a single dispatch by its ID"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    id: builtins.int
    """The dispatch identifier"""
    def __init__(
        self,
        *,
        id: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["id", b"id"]) -> None: ...

global___DispatchDeleteRequest = DispatchDeleteRequest
