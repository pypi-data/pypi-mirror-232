# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['cappa']

package_data = \
{'': ['*']}

install_requires = \
['docstring-parser>=0.15,<0.16',
 'typing-extensions>=4.7.1,<5.0.0',
 'typing-inspect>=0.9.0,<0.10.0']

extras_require = \
{'rich': ['rich', 'rich-argparse']}

setup_kwargs = {
    'name': 'cappa',
    'version': '0.5.0',
    'description': '',
    'long_description': '# Cappa\n\n[![Actions Status](https://github.com/DanCardin/cappa/actions/workflows/test.yml/badge.svg)](https://github.com/dancardin/cappa/actions)\n[![Coverage Status](https://coveralls.io/repos/github/DanCardin/cappa/badge.svg?branch=main)](https://coveralls.io/github/DanCardin/cappa?branch=main)\n[![Documentation Status](https://readthedocs.org/projects/cappa/badge/?version=latest)](https://cappa.readthedocs.io/en/latest/?badge=latest)\n\nSee the full documentation [here](https://cappa.readthedocs.io/en/latest/).\n\nCappa is a more declarative take on command line parsing library, which takes\nmuch of its inspiration from Rust\'s\n[Clap](https://docs.rs/clap/latest/clap/_derive/index.html) library(\'s derive\nAPI).\n\n```python\nfrom __future__ import annotations\n\nimport cappa\nfrom typing_extensions import Annotated\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Example:\n    """Example program\n\n    Args:\n       name: Required name argument\n       flag: optional flag to enable\n    """\n\n    name: str  # positional arg\n    flag: bool  # --flag\n    flags: Annotated[list[str], cappa.Arg(short=True, long=True)]\n    value: Annotated[int, cappa.Arg(short="-v", long="--val")]\n\n    subcommand: Annotated[MeowCommand | BarkCommand, cappa.Subcommand]\n\n\n@dataclass\nclass MeowCommand:\n    ...\n\n\ndef bark(bark: BarkCommand):\n    print(bark)\n\n\n@cappa.command(name="bark", invoke=bark)\n@dataclass\nclass BarkCommand:\n    ...\n\n\n# invoke cli parsing\ndef main():\n    args: Example = cappa.parse(Example)\n    print(args)\n    ...\n\n\n    # Or click-like automatic invocation of the command, where `example bark` would call `bark`.\n    cappa.invoke(Example)\n```\n\nGenerates CLI help text like:\n\n```\n[-h] --flag -f FLAGS -v VALUE name {meow-command,bark} ...\n\nExample program\n\npositional arguments:\n  name                  Required name argument\n\noptions:\n  -h, --help            show this help message and exit\n  --flag                optional flag to enable\n  -f FLAGS, --flags FLAGS\n  -v VALUE, --val VALUE\n\nsubcommand:\n\n  {meow-command,bark}\n    meow-command        MeowCommand()\n    bark                BarkCommand()\n```\n\n- See\n  ["annotation" documentation](https://cappa.readthedocs.io/en/latest/annotation.html)\n  for information on how type hinting affects runtime behavior.\n\n- See\n  ["invoke" documentation](https://cappa.readthedocs.io/en/latest/invoke.html)\n  for information on click-like automatic function invocation.\n\n## Why?\n\nA fair question. The incumbants, with click/typer and argparse have been readily\nserving python for a long time, and will certainly continue to do so.\n\nHaving use the "derive API" from Rust\'s\n[Clap](https://docs.rs/clap/latest/clap/_derive/index.html) library, it\'s just\nreally really nice to use, because the API is so natural. It became obvious that\npython could obviously support a similar API and it was surprising that one\ndidn\'t already exist.\n\nHopefully with `cappa`, you get the flexibility to utilized either the\ncommand-forward design given by `click`/`typer` or the manual handling given by\n`argparse` (and even `clap`).\n\n> Why not click?\n\nI\'ve used click for years, it\'s certainly a good library. There are some aspects\nof its design that make it really frustrating to use beyond small projects with\na single entrypoint.\n\n- Many of the issues stem from the fact that click wraps the called function,\n  and changes its behavior. Calling the resultant function invokes the CLI.\n\n  You want to call that function in two places? you need to use `click.invoke`.\n\n  You want to do this in tests? You need to deal with its `ClickRunner` that\n  accepts args as a list of string, and output in terms of stdout and stderr. In\n  terms of tests, this is really large drop in UX relative to a plain function\n  (with args) you can call.\n\n  You want to avoid click-isms in either case? You need to (basically) duplicate\n  your function. One wrapped in click decorators, which just defers to a similar\n  function that just accepts the arguments.\n\n  - `Cappa` inverts the relationship to invoked functions. You do not wrap the\n    functions, so they end up just being plain functions you can call in any\n    scenario.\n\n    And in the case of the decorated classes, the resultant class is directly\n    returned. It should act exactly like the dataclass/pydantic model you\n    defined.\n\n    Even parsing or invoking the CLI through `Cappa`\'s mechanisms to parse the\n    argv, in tests for example, the result is **much** more similar to just\n    executing the function in the first place.\n\n- Click imperitively accumulates the CLI\'s shape based on where/how you combine\n  groups and commands. Intuiting what resultant CLI looks like from the series\n  of click commands strung together is not obvious.\n\n  - `Cappa` centrally declares the CLI shape based on types. For all of the\n    reasons pydantic models can be easily used to describe a potentially deeply\n    nested schema, with `Cappa` it\'s very easy to look at the model and\n    determine the total set of arguments and subcommands relative to it.\n\n- Because click tightly couples the called function with click itself, a large\n  enough CLI will inevitably slow down starup because you\'re forced to\n  transitively import your whole codebase in order to describe the state of the\n  CLI itself.\n\n  - `Cappa` allows you to define the CLI in a way where you **could** define the\n    CLI shape/calls in complete isolation with no (lazy) imports to the rest of\n    your code.\n\n- The Click "Context" appears to be its only mechanism for providing\n  non-argument dependencies to commands/subcommands. And `pass_context` (and the\n  mutation of the context) is a very blunt tool, that secretly couples the\n  implementations of different commands together.\n\n  - `Cappa` uses the same dependency resolution mechanisms it uses for arguments\n    to provide the result of arbitrary functions to your commands (Reminiscent\n    of FastAPI\'s `Depends`).\n\n    For example, some subcommand require loading config, some commands require a\n    database connection (or whatever) which itself depends on that config. What\n    would be a, relatively, more difficult task using the click context (or\n    manually littering the loading of these things inside the bodies of the\n    commands) uses the same API as the rest of `Cappa`.\n\n- With `click`, it\'s impossible(? or at least not clear how) to perform\n  `argparse`-like (or Clap) ability to just parse the structure and return the\n  parsed output shape.\n\n  - `Cappa` provides a separate `parse` function and `invoke` function. You can\n    choose either style, or both.\n\n> Okay, so you like types, why not [Typer](https://typer.tiangolo.com/)\n\nTyper has a lot of good ideas, inspired by Hug before it. While the actual\ninspiration for Cappa is\n[Clap](https://docs.rs/clap/latest/clap/_derive/index.html), the annotation\nresults for arguments end up looking a lot like typer\'s args!\n\nUnfortunately, Typer is **basically** Click (with type-inferred arguments), and\nhas all of the same drawbacks.\n\nIf `tiangolo` hadn\'t based typer on click, it\'s not crazy to imagine that\n`cappa` look something like what he might have come up with. In particular the\n`Dep` feature of `cappa` looks and feels a lot like the `Depends` feature of\nFastAPI.\n\n> Why not argparse?\n\nThe imperitive style of argparse can just be tedious to read/write, and hard to\nintuit what the shape of the resultant CLI will look like. `Cappa` currently\nuses argparse as the underlying argument parsing library, because it is the most\nstraightforward, maintained, python library for building this sort of\ndeclarative system upon.\n\n## Internals\n\nInternally, cappa is (currently) implemented on top of the built-in `argparse`\nlibrary. However, all of the commandline parsing logic is centrally factored,\nand the **actual** library/code underlying the parsing should be considered an\nimplementation detail.\n',
    'author': 'DanCardin',
    'author_email': 'ddcardin@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'extras_require': extras_require,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
