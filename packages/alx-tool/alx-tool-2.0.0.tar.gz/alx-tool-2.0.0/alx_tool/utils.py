import re
import stat
import json
import html
from pathlib import Path

def get_url(value):
    """Get the project URL from the provided value, ensuring it matches alx project link pattern."""

    url_pattern = r"https://intranet\.alxswe\.com/projects/\d+"

    if re.match(url_pattern, value):
        return value

    return f"https://intranet.alxswe.com/projects/{value}"

# initialize project
def init_project(project):
    project_title = project.get("title")

    for task in project.get("tasks", []):
        # get project directory, for task
        project_directory = task.get("directory")

        if project_directory is not None:
            # get .alx directory
            project_path, dot_alx_path = create_project(project_directory)

            create_description(dot_alx_path, project_title)
            create_project_info(dot_alx_path, project)
            create_gitignore(project_path, project_directory)
            create_readme_file(project_path, project_directory, project_title, task)
            create_task(project_path, project_directory, task)

            # create .alx/config file

def create_project(project_directory):
    """Create a project directory and .alx subdirectory."""
    
    # validate project path
    current_path = Path.cwd()

    # check if project directory exists in the current directory or any parent directories
    project_path = next((path.absolute() for path in [current_path] + list(current_path.parents) if (path / project_directory).exists()), Path("."))

    # create .alx directory
    dot_alx_path = project_path / project_directory / ".alx"

    if dot_alx_path.exists():
        return project_path, dot_alx_path

    dot_alx_path.mkdir(parents=True, exist_ok=True)
    
    return project_path, dot_alx_path

def create_description(dot_alx_path, project_title):
    # create .alx/description file
    description_path = dot_alx_path / "description"

    if not description_path.exists():
        with description_path.open("w", encoding="utf-8") as description_file:
            description_file.write(project_title)

def create_project_info(dot_alx_path, project):
    # create .alx/info/project file
    project_info_path = dot_alx_path / "info" / "project"

    if not project_info_path.exists():
        project_info_path.parent.mkdir(parents=True, exist_ok=True)
    
        with project_info_path.open("w", encoding="utf-8") as project_info_file:
            project_info_file.write(json.dumps(project, indent=4))
            
def create_gitignore(project_path, project_directory):
    # create .gitignore
    dot_git_ignore_path = project_path / project_directory / ".gitignore"
    dot_git_ignore_content = [
        "# Automatically generated by alx-tool (https://github.com/AmonMunyai/alx-tool)\n",
        "# Ignore all main.c files\n",
        "*-main.c\n",
        "\n",
        "# Ignore the Makefile\n",
        "Makefile\n",
        "\n",
        "# Ignore the .alx directory and its contents\n",
        ".alx/\n",
        "\n",
        "# Ignore any executable generated\n",
        "*.out\n",
    ]

    if not dot_git_ignore_path.exists():
        with dot_git_ignore_path.open("w", encoding="utf-8") as dot_git_ignore_file:
            dot_git_ignore_file.writelines(dot_git_ignore_content)

    # if a .gitignore file already exists append to end
    # if dot_git_ignore_path.exists():
    #     with dot_git_ignore_path.open(encoding="utf-8") as dot_git_ignore_file:
    #         lines = dot_git_ignore_file.readlines()

    #         if ".alx\n" not in lines:
    #             lines.extend(dot_git_ignore_content)

    #             with dot_git_ignore_path.open("w", encoding="utf-8") as dot_git_ignore_file:
    #                 dot_git_ignore_file.writelines(dot_git_ignore_content)
    
def create_readme_file(project_path, project_directory, project_title, task):
    # create_readme_file
    readme_file_path = project_path / project_directory / "README.md"

    # content to be written to readme file, project title
    readme_file_content = [
        f"# {project_title}\n",
        "\n",
        f"## {task.get('title')}\n",
        "\n",
        "---\n",
        "\n",
        "*This README.md file was automatically generated by [alx-tool](https://github.com/AmonMunyai/alx-tool).*\n",
        "\n",
        "*Please note that this README is dynamically generated and may not always reflect the most up-to-date information about the project.*\n",
        "\n",
        "---\n",
    ]

    if readme_file_path.exists():
        with readme_file_path.open("r", encoding="utf-8") as readme_file:
            readme_file_content = readme_file.readlines()

            readme_file_content.insert(-9, f"## {task.get('title')}\n\n")

    for current_line in task.get("body", []):
        current_line = process_readme_line(current_line)
        readme_file_content.insert(-9, f"{current_line}\n")

    # write to file
    with readme_file_path.open("w", encoding="utf-8") as readme_file:
        readme_file.writelines(readme_file_content)

def process_readme_line(line):
    # unescape HTML entities
    line = html.unescape(line)

    # define regular expressions for replacements
    tag_replacements = [
        (r"<p>(.*?)</p>", r"\1\n"),
        (r"<ul>", ""),
        (r"</ul>", ""),
        (r"<ol>", ""),
        (r"</ol>", ""),
        (r"<li>(.*?)</li>", r"- \1"),
        (r"<strong>(.*?)</strong>", r"**\1**"),
        (r"<em>(.*?)</em>", r"*\1*"),
        (r"<br>", "\n"),
        (r"<h1>(.*?)</h1>", r"# \1\n"),
        (r"<h2>(.*?)</h2>", r"## \1\n"),
        (r"<h3>(.*?)</h3>", r"### \1\n"),
        (r"<h4>(.*?)</h4>", r"#### \1\n"),
        (r"<h5>(.*?)</h5>", r"##### \1\n"),
        (r"<h6>(.*?)</h6>", r"###### \1\n"),
        (r"<pre><code>(.*?)", r"```bash\n\1"),
        (r"(.*?)</code></pre>", r"\1```"),
        (r"<pre>(.*?)</pre>", r"```bash\n\1\n```"),
        (r"<code>(.*?)</code>", r"`\1`"),
        (r"<blockquote>(.*?)</blockquote>", r"> \1\n"),
        (r"<hr>", "---\n"),
    ]

    for pattern, replacement in tag_replacements:
        line = re.sub(pattern, replacement, line)

    return line

def load_project():
    """Load the project information from .alx/info/project."""

    project_info_path = Path("./.alx/info/project")
        
    if project_info_path.exists():
        with project_info_path.open("r", encoding="utf-8") as project_info_file:
            return json.load(project_info_file)

    raise SystemExit("No project information found. Please run 'init' to create or initialize a project.")

def create_task(project_path, project_directory, task):
    """Create task files and directories."""
    filtered_task = {key: value for key, value in task.items() if value is not None}
            
    if not filtered_task:
        return
    
    files_to_create = task.get("files", [])

    for file in files_to_create:
        create_task_file(project_path, project_directory, file, task)

def create_task_file(project_path, project_directory, file, task):
    """Create a task file."""
    file = file.strip()
    task_file_path = project_path / project_directory / file

    # ensure that parent directories exist
    if "/" in file:
        task_file_path.parent.mkdir(parents=True, exist_ok=True)

    # create task file if it doesnt exists
    if not task_file_path.exists():
        task_file_path.touch()
        print(f"Created: {task_file_path.name}")

        # handle specific file types
        file_extension = task_file_path.suffix

        # handle bash files or bash scripts
        if file_extension == "":
            handle_bash(task_file_path)

        # handle c files
        elif file_extension == ".c":
            handle_c(task_file_path, task.get("prototypes", []), task.get("body", []))

# Bash utility functions
def handle_bash(task_file_path):
    """Handle bash task file."""

    with task_file_path.open("w", encoding="utf-8") as task_file:
        task_file.write("#!/bin/bash\n")

    # add execute permissions
    task_file_path.chmod(task_file_path.stat().st_mode | (stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH))

# C utility functions
def handle_c(task_file_path, task_file_prototypes, task_file_body):
    """Handle C task file."""

    task_file_content = generate_task_file_content(task_file_prototypes)
    write_task_file(task_file_path, task_file_content)

    makefile_path = task_file_path.parent / "Makefile"
    gcc_command = get_gcc_command(task_file_body)

    if gcc_command:
        if "_putchar.c" in gcc_command:
            create_putchar(task_file_path.parent)

        update_makefile(makefile_path, task_file_path.stem, gcc_command)

    main_c_file_name, main_c_file_content = extract_main_c_content(task_file_body)

    if main_c_file_name and main_c_file_content:
        create_main_c_file(task_file_path.parent, main_c_file_name, main_c_file_content)
    
    create_main_h_file(task_file_path.parent, task_file_prototypes)

def generate_task_file_content(task_file_prototypes):
    """Generate content for the C task file."""
    task_file_content = [
        "#include <stdio.h>\n",
        "\n",
        "/* betty style doc for function main goes here */\n",
        "\n",
        "int main(void)\n",
        "{\n",
        "\t/* your code goes here */\n",
        "\treturn (0);\n",
        "}\n",
    ]

    # get prototype, and update boilerplate -> and create main.h file and add prototypes
    for prototype in task_file_prototypes:
        if prototype is not None:
            prototype = prototype.strip()
            task_file_content = [
                "#include \"main.h\"\n",
                "\n",
                "/* betty style doc for function prototype goes here */\n",
                "\n",
                "{}\n".format(prototype.replace(";", "")),
                "{\n",
                "\t/* your code goes here */\n",
                "}\n",
            ]

    return task_file_content

def write_task_file(task_file_path, task_file_content):
    """Write content to the task file."""
    # add boilerplate
    with task_file_path.open("w", encoding="utf-8") as task_file:
        task_file.writelines(task_file_content)

def get_gcc_command(task_file_body):
    """Extract the GCC compile command from task_file_body."""
    task_code = None

    for line in task_file_body:
        if "<pre>" and "</pre>" in line:
            task_code = line.split("\n")
            break
    
    gcc_command = None

    if task_code:
        for linux_command in task_code:
            match = re.search(r"(gcc .*)", linux_command)

            if match:
                gcc_command = match.group(0)
                gcc_command = html.unescape(gcc_command)
                break
    
    return gcc_command

def create_putchar(project_directory):
    """Create _putchar.c file in the project directory."""
    putchar_file_path = project_directory / "_putchar.c"


    if not putchar_file_path.exists():
        with putchar_file_path.open("w", encoding="utf-8") as putchar_file:
            putchar_file.writelines([
                "#include <unistd.h>\n"
                "\n"
                "/**\n"
                " * _putchar - writes the character c to stdout\n"
                " * @c: The character to print\n"
                " *\n"
                " * Return: On success 1.\n"
                " * On error, -1 is returned, and errno is set appropriately\n"
                " */\n"
                "int _putchar(char c)\n"
                "{\n"
                "\treturn (write(1, &c, 1));\n"
                "}\n"
            ])

def update_makefile(makefile_path, task_name, gcc_command):
    """Create or update the Makefile for the task."""
    # create Makefile
    makefile_content = [
        "# This Makefile was auto-generated by alx-tool.\n",
        "# For the latest version and source code, visit:\n",
        "# https://github.com/AmonMunyai/alx-tool\n",
        "\n",
        "# Rules to compile C task files to executable\n",
        f"{task_name}:\n",
        f"\t{gcc_command}\n",
        "\n",
        "clean:\n",
        f"\t@rm -f {task_name}\n",
        "\t@printf \"\e[34mAll clear!\e[0m\\n\"\n",
    ]

    if makefile_path.exists():
        with makefile_path.open("r", encoding="utf-8") as makefile:
            makefile_content = makefile.readlines()

            # check if recipe exists
            if not f"\t{gcc_command}\n" in makefile_content:
                # insert recipe
                makefile_content.insert(-3, f"{task_name}:\n")
                makefile_content.insert(-3, f"\t{gcc_command}\n")
                makefile_content.insert(-3, "\n")

                # add to executables to clean
                makefile_content[-2] = makefile_content[-2].replace("\n", f" {task_name}\n")
    
    # write to makefile
    with makefile_path.open("w", encoding="utf-8") as makefile:
        makefile.writelines(makefile_content)

def extract_main_c_content(task_file_body):
    """Extract the content for the main.c file from task_file_body."""
    # create main.c file associated with the current task file
    main_c_file_name = None
    main_c_file_content = None

    for linux_command in task_file_body:
        match = re.search(r"cat (\d*-?main\.c)", linux_command)

        if match:
            main_c_file_name = match.group(1)
            lines = linux_command.split("\n")
            break

    if main_c_file_name:
        start_index = 1
        end_index = None

        for index, line in enumerate(lines):
            lines[index] = process_readme_line(line)

            if line.endswith("}"):
                end_index = index + 1
        
        main_c_file_content = lines[start_index: end_index]

    return main_c_file_name, main_c_file_content

def create_main_c_file(project_directory, main_c_file_name, main_c_file_content):
    """Create main.c file associated with the current task file."""
    main_c_file_path = project_directory / main_c_file_name

    with main_c_file_path.open("w", encoding="utf-8") as main_c_file:
        for line in main_c_file_content:
            main_c_file.write(f"{line}\n")

def create_main_h_file(project_directory, prototypes):
    """Create or update main.h file with function prototypes."""
    project_name = project_directory.name
    main_h_file_path = project_directory / "main.h"

    main_h_content = [
        "#ifndef MAIN_H\n",
        "#define MAIN_H\n",
        "\n",
        "/*\n",
        " * File: main.h\n",
        " * Desc: Header file containing declarations for all functions\n",
        f" *       used in the {project_name} directory\n",
        " */\n",
        "\n",
        "int _putchar(char c);\n",
        "\n",
        "#endif /* MAIN_H */\n",
    ]

    if main_h_file_path.exists():
        with main_h_file_path.open("r", encoding="utf-8") as main_h_file:
            main_h_content = main_h_file.readlines()

    # insert new prototype
    for prototype in prototypes:
        prototype_line = f"{prototype}\n"

        if prototype_line not in main_h_content:
            main_h_content.insert(-3, prototype_line)

    # write to file
    with main_h_file_path.open("w", encoding="utf-8") as main_h_file:
        main_h_file.writelines(main_h_content)        
        
    # add main.c files to .gitignore
