'''Generates slightly corrupted "form" data sources from randomly generated base/reference data'''
import argparse
from os import listdir, environ, path
from typing import List, Dict, Union
import numpy as np
from scipy import stats
import pandas as pd
from itertools import chain
from enum import Enum, auto

from rsidatasciencetools.sqlutils.sqlconfig import SQLConfig
from rsidatasciencetools.config.baseconfig import YmlConfig
from rsidatasciencetools.sqlutils.sql_connect import DbConnectGenerator
from rsidatasciencetools.datautils.datagen import (NameIdDataType, TaxPayerType, Record, Source, 
    random_datetimes, get_no, gen_records_from_data)

try:
    from tqdm import tqdm 
except ImportError:
    tqdm = None

# confusion matrix elements for creating noisy spellings of words
hw_conf_chars = [
    {'a','o','c','C','G','Q','g','d'},
    {'t','7','1','z','Z','f','4','A'},
    {'b','p','q'},
    {'m','n'},
    {'u','w'},
    {'3','5','S','s','8','Z','z'}
]
querty_conf_dict = {
    'a':'qwsz','b':'vgnh','c':'xdfv','d':'serfcx','e':'w34rds','f':'drtgvc','g':'ftyhbv',
    'h':'gyujnb','i':'89okju','j':'huikmn','k':'jiolm','l':'kop','m':'njk','n':'bhjm',
    'o':'i90plk','p':'o0l','q':'12wsa','r':'e45tfd','s':'awedxz','t':'r46ygf','u':'y78ijh',
    'v':'cfgb','w':'q23esa','x':'zsdc','y':'t67uhg','z':'asx','0':'9op','1':'qw2','2':'1qwe3',
    '3':'2wer4','4':'3ert5','5':'4rty6','6':'5ty7','7':'6yu8','8':'7ui9','9':'8io0'}
qwerty_conf_chars = [set(k+v) for k,v in querty_conf_dict.items()]

hw_conf_nums = [
    {'1','7','4'},
    {'8','2'},
    {'9','6','0'},
    {'3','5','8'}
]

all_alpha_num = [chr(ord('0')+i) for i in range(75) if i < 10 or (i >=17 and (i < 43 or i >= 49))]
all_alpha_num_nocase = [chr(ord('0')+i) for i in range(75) if i < 10 or (i >= 49)]
all_num = [chr(ord('0')+i) for i in range(10)]
all_alpha = [k for k in all_alpha_num if k not in all_num]
all_alpha_nocase = [k for k in all_alpha_num_nocase if k not in all_num]

hw_conf_alpha = [set(''.join([v for v in _set if v not in '0123456789'])) for _set in hw_conf_chars]
querty_conf_num = [set(k+''.join([v for v in querty_conf_dict[k] if v in '0123456789'])) for k in all_num]
querty_conf_alpha = [set(k+''.join([v for v in querty_conf_dict[k] if v not in '0123456789'])) 
    for k in [vv for vv in all_alpha_nocase if vv not in all_num]]


class FormDataType(Enum):
    """The FormDataType class is an enumeration class that defines
    the different types of `form data` that can be generated by the
    `TaxFormData` class. Each enum value corresponds to a specific
    type of form data, such as tax payer type, first name, etc.
    """
    taxpayertype = auto()
    firstname = auto()
    lastname = auto()
    middlename = auto()
    ethnicity = auto()
    compositename = auto()
    maidenname = auto()
    birthday = auto()
    taxid = auto()
    compositeaddress = auto()
    streetno = auto()
    aptno = auto()
    streetname = auto()
    city = auto()
    zipcode = auto()
    state = auto()
    phoneno = auto()
    email = auto()
    formname = auto()
    taxyear = auto()
    agi = auto()
    deductotal = auto()
    metric_id = auto()


class CMtype(Enum):
    """ The CMtype class is an enumeration that represents the types
        of character masks representing typical typos that occur in a
        keyboard or in a handwritten interpretation, that can be used
        to generate random noisy strings:
    `qwerty_alpha_num`: includes all QWERTY keyboard characters, both
        alphabetical and numerical.
    `qwerty_alpha`: includes only alphabetical characters found on a
        QWERTY keyboard.
    `qwerty_num`: includes only numerical characters found on a QWERTY
        keyboard.
    `hw_alpha_num`: includes handwritten characters, numberical and
        alphanumerical.
    `hw_alpha`: includes only alphabetical handwritten characters.
    `hw_num`: includes only numerical handwritten characters.
    """
    qwerty_alpha_num = auto()
    qwerty_alpha = auto()
    qwerty_num = auto()
    hw_alpha_num = auto()
    hw_alpha = auto()
    hw_num = auto()

class ConfusionMat(Source):
    """ This class generates slightly corrupts "form" data sources
        from randomly generated base/reference data.

    Args:
        prob_e:float. Probability of corrupting an entry in the data
            record. Default to 0.01
        cm_type: the type of corruption to be applied to the entry.
            Default to alfanumeric keyboard characters: 
            CMType.qwerty_alph_num
    """
    def __init__(self, prob_e=0.01, cm_type=CMtype.qwerty_alpha_num, **kwargs):
        Source.__init__(self, 'ConfusionMat', **kwargs)
        self.prob_e = prob_e
        self.cm_type = cm_type

        if cm_type == CMtype.qwerty_alpha_num:
            kwargs.update(dict(char_set=all_alpha_num_nocase, 
                conf_set=qwerty_conf_chars, preserve_case=True))
            self.contains_alpha_num = (True,True)
        elif cm_type == CMtype.qwerty_alpha:
            kwargs.update(dict(char_set=all_alpha_nocase, 
                conf_set=querty_conf_alpha, preserve_case=True))
            self.contains_alpha_num = (True,False)
        elif cm_type == CMtype.qwerty_num:
            kwargs.update(dict(char_set=all_num, 
                conf_set=querty_conf_num))
            self.contains_alpha_num = (False,True)
        elif cm_type == CMtype.hw_alpha_num:
            kwargs.update(dict(char_set=all_alpha_num, 
                conf_set=hw_conf_nums))
            self.contains_alpha_num = (True,True)
        elif cm_type == CMtype.hw_alpha:
            kwargs.update(dict(char_set=all_alpha, 
                conf_set=hw_conf_alpha))
            self.contains_alpha_num = (True,False)
        elif cm_type == CMtype.hw_num:
            kwargs.update(dict(char_set=all_num, 
                conf_set=hw_conf_nums))
            self.contains_alpha_num = (False,True)
        else:
            raise TypeError(f'unknown Confusion Matrix type: {cm_type}')

        if cm_type in [CMtype.qwerty_alpha_num, CMtype.qwerty_alpha, CMtype.qwerty_num]:
            self.is_hw, self.is_qwerty = False, True
        else:
            self.is_hw, self.is_qwerty = True, False

        self.setup(**kwargs)

    def setup(self, char_set: set = None, conf_set: set = None,
            preserve_case:bool = False, **kwargs):
        """The setup method sets up the confusion matrix used to
        corrupt entries in a record. 
        The method sets up a dictionary called `data` where each
        character in `char_set` is a key and the value is a list of
        characters that can be confused with it according to 
        `conf_set`. 
        For each character in `char_set`, the method sets up a
        `sample_weight` dictionary which assigns a weight to each
        character in `data[char]`. 

        Args:
            char_set: set of all possible characters that can be
                used in a record. Defaults to None.
            conf_set: set of tuples where each tuple contains
                characters that can be confused with each other.
                For example, ('0', 'O') or ('1', 'I', 'L').
                Defaults to None.
            preserve_case: bool. If True, the key case (uppercase/
                 lowercase) is preserved in the generated corrupted
                 entry. If False, it is returned lowercase.
                 Defaults to False.
        """
        
        assert char_set is not None and conf_set is not None, ('char_set and conf_set not set, '
            'use child class confusion matrix class')
        # get all number and upper/lower case letters
        self.preserve_case = preserve_case
        self.char_set = char_set
        self.data = {char: [] for char in self.char_set}
        self._weights_all_chars = np.ones(len(self.char_set)) / float(len(self.char_set))
        for charset in conf_set:
            for charLU in charset:
                for charEl in charset:
                    if charLU != charEl:
                        self.data[charLU].append(charEl)
        self.data = {charLU: list(chain([charLU],set(self.data[charLU]))) 
            for charLU in self.data}
        self.sample_weight = {char: np.array([1.0] if len(self.data[char]) == 1 
            else [(1.0-self.prob_e if i == 0 else self.prob_e/(len(self.data[char])-1.)) 
            for i in range(len(self.data[char]))]) for char in self.data}
        self.sample_weight = {char: weights/weights.sum() 
            for char, weights in self.sample_weight.items()}

    def __getitem__(self, key:str):
        """ It aims to corrupt the `key` entry. 
        If the `key` is not in the char_set, it is returned
        unchanged. Otherwise, a random error is introduced based on
        the confusion matrix set during initialization
        (char_set and conf_set).
        The probability of introducing an error is object's `prob_e`. 
        If the preserve_case flag is set, the case of the input
        character is preserved in the output. 

        Args:
            key (str): string to be corrupted

        Raises:
            e: general Exception
            ke: KeyError when a dictionaty key is not found

        Returns:
            A character that may be corrupted or unchanged depending
            on the specified confusion matrix type and the
            probability of error. 
            If the input character is not in the character set, it
            returns the input character. 
            If `preserve_case` is True, it preserves the case of the
            input character `key`.
        """
        
        if key not in self.char_set:
            return key
        if self.preserve_case:
            isup = key.isupper()
            key = key.lower()
        try:
            debug = False
            debug and print(f'ConfMat: getting corrupted entry - cmtype: {self.cm_type}, rng sum(state): {self.rng.get_state()[1].sum()} <- input: {key}')
            if self.rng.uniform() < self.prob_e:
                debug and print('drawing from all characters')
                char = self.get_sample(data=self.char_set, 
                    sample_weight=self._weights_all_chars)
                debug and print(f'all chars:\n{self.char_set}\nweights:\n{self._weights_all_chars}')
            else:
                debug and print('drawing from limited error set')
                char = self.get_sample(data=self.data[key],
                    sample_weight=self.sample_weight[key])
                debug and print(f'all chars:\n{self.data[key]}\nweights:\n{self.sample_weight[key]}')
            debug and print(f'selected error: {char}')
            return (char.upper() if self.preserve_case and isup else char)
        except ValueError as e:
            print(f'trying to get corrupted value for "{key}"')
            print(f'sampling from: {self.data[key]}, with weights: '
                f'sum {self.sample_weight[key]} = {sum(self.sample_weight[key])}')
            raise e
        except KeyError as ke:
            print(f'could not find {key} in {list(self.data.keys())} element(s) available')
            raise ke


class FormRecord(Record):
    """The FormRecord class is a subclass of the Record class. 
    It has its own constructor (__init__) method which initializes
    the class with a specific datatype argument (FormDataType), 
    which defines the types of data that can be stored in an
    instance of the FormRecord class. 
    

    Args:
        datatype: the type of data for the record. By default, 
            FormDataType
        Additional arguments can be passed to the constructor as
            kwargs and are forwarded to the parent constructor.
    """
    def __init__(self, datatype=FormDataType, **kwargs) -> None:
        super().__init__(datatype=datatype, **kwargs)

class TaxFormData(Source):
    """The TaxFormData class generates a sample of tax form data
    using specified distributions for each type of data. 
    The class inherits from the Source class and uses its methods
    to generate samples. 
    The distributions are specified in the shape_params_by_type
    parameter, which is a dictionary where the keys are the data
    types and the values are dictionaries of parameters for each
    distribution with a defaulted value for formname(the name of
    the tax form), taxyear (the tax year), agi (the adjusted gross
    income), and deductotal (the total deductions).
    """
    def __init__(self, src_data: str = None, shape_params_by_type: Dict = {
                'agi':{'loc':50e3, 'scale': 25e3},
                'taxyear': {'start':pd.Timestamp('2002-01-01'), 
                'end': pd.Timestamp('2022-12-31')},
                'deductotal': {'loc':15e3, 'scale': 5e3}
                }, 
            rng=None, seed: int = None) -> None:
        super().__init__(src_data, rng, seed)
        self.set_distribution(self.rng.normal, constraints=[
            ((np.ndarray, float), lambda x: np.maximum(x,0.)),
            ((np.ndarray, float), lambda x: np.round(x,2))])
        self.shape_params_by_type = shape_params_by_type

    def __repr__(self):
        s = Source.__repr__(self)
        s += '\n ' + str(self.shape_params_by_type)
        return s

    def get_sample(self):
        """The get_sample method generates a sample of tax form data
        using the distributions specified in shape_params_by_type. 

        Returns:
            A dictionary that includes the form name, tax year, 
                adjusted gross income, and total deductions.
        """
        agi = super().get_sample(shape_params=self.shape_params_by_type['agi'])    
        dt = random_datetimes(rng=self.rng, **self.shape_params_by_type['taxyear'])
        deductotal = super().get_sample(shape_params=self.shape_params_by_type['deductotal'])
        
        return {'formname': self.src_data, 'taxyear': dt.year, 
            'agi': agi, 'deductotal': deductotal} 

class EntryDataCorrupter(Source):
    """This is a class to introduce errors in input data. It takes as
    input a data item that may be numeric, string, or timestamp,
    and randomly decides to introduce errors in the data.
    
    It first decides whether the data was scanned from a handwritten
    document or not. Then, it may substitute a character in the data
    with another one, insert an extra character, or erase a
    character based on the probabilities through the `prob_e` and
    `prob_hw` parameters.

    This class uses confusion matrices to determine which characters
    to substitute when introducing errors. The confusion matrices
    are initialized based on the CMtype enumeration class.

    Args:
        data: the input data to be corrupted. Defaults to None.
        prob_e: the probability of introducing an error.
             Defaults to 0.05.
        prob_hw: the probability that the input data was scanned
             from a handwritten document. Defaults to 0.1.
        rng: a random number generator object. Defaults to None.
        seed: an integer seed value for the random number generator.
             Defaults to None.
        debug:int. A flag indicating whether to print debugging
             information. Defaults to 0.

    Returns:
        If the input data is not corruptible, the function returns
        the original data. Otherwise, it returns the corrupted data.

    Methods:
        reset_type: assigns the handwritten origin of the document
        convert_back: converts a given input into a type. 
        More details in the methods itself.
    
    """
    def __init__(self, data=None, prob_e:float = 0.05, prob_hw: float = 0.1,
            rng=None, seed: int = None, debug=0) -> None:
        super().__init__(data, rng, seed)
        self.debug = debug
        self.data = data
        self.original = data
        self.prob_hw = prob_hw
        self.prob_e = prob_e
        cms = [ConfusionMat(prob_e=prob_e,cm_type=cmtype,seed=seed+ii)
            for ii, cmtype in enumerate(CMtype)]
        self.corrupters_isHW_alpha_num = {(cm.is_hw,*cm.contains_alpha_num): cm 
            for cm in cms}
        self.reset_type()

    def reset_type(self):
        """ Assigns the handwritten origen of the document based
        on the probability of handwritten attribute `prob_hw`
        """
        self.is_hw = self.rng.uniform() < self.prob_hw

    def convert_back(self,data):
        """Converts a given input data into the specified 
        type in `_type`.
        If the data cannot be converted, returns a message
        indicating failure. If the data is type TimeStamp, it
        returns the original data along with a flag indicating
        failure.
        """
        try:
            return self._type(''.join(data)), True
        except ValueError as e:
            if self.isTS:
                return self.data, False
            print(f'trying to convert: {data} to {self._type}')
            raise e

    def get_sample(self, data, length_can_change=True):
        """
        Generates a corrupted version of the input data, with
        optional changes to its length.

        Args:
            data: the input data to be corrupted.Possible types are:
                string, number (e.g., integer, float), Pandas
                Timestamp or NumPy datetime64 object, None.
            length_can_change: whether the length of the data can be
                changed during corruption. Defaults to True.

        Returns:
            The corrupted version of the input data.

        This function generates a corrupted version of the input
        data using a combination of substitution, insertion, and
        erasure errors. The occurrence of these errors is
        randomly determined based on a set probability, which can be
        adjusted by the user. The function also randomly decides if
        the input data was scanned from handwritten documents and
        uses this information to select a set of corrupters to apply
        to the data. 

        Note that if the input data is None or NaN, or if it is of
        type float or int and its value is NaN, the function will
        return the input data unmodified.
        """

        if data is None or (isinstance(data,(float,int)) and np.isnan(data)):
            return data
        self.data = self.original = data
        self.isnumeric = isinstance(data,(float, float, int))
        self._type = type(data)
        self.isstrnumeric = isinstance(data,str) and data.strip().isnumeric()
        self.isalpha = isinstance(data,str) and data.strip().isalpha()
        self.isTS = isinstance(data,(pd.Timestamp,np.datetime64))

        # randomly decide the input data was scanned from handwritten documents
        corrupter_CM = self.corrupters_isHW_alpha_num[(
            self.is_hw,
            self.isalpha or not(self.isstrnumeric or self.isnumeric or self.isTS),
            (self.isstrnumeric or self.isnumeric or self.isTS) or not(self.isalpha))]

        # ------- randomly decide when to corrupt the data ------- 


        # --- substitution errors ---
        data = self.data
        if self.isnumeric or self.isTS:
            data = str(data)
        n_edits = self.rng.poisson(lam=max(1,int(len(data)/4))/(1.0-self.prob_e))
        # .randint(1,max(2,int(len(self.data)/2)))
        if self.debug and len(n_edits):
            print('substituting data values at indices')
        for e in range(n_edits):
            for _ in range(1+9*int(self.isTS)):
                data = self.data
                if self.isnumeric or self.isTS:
                    data = str(data)
                pos = -1
                for _ in range(5):
                    if pos > 0 and (data[pos] not in [' ', '.', ',',':','-']):
                        break
                    pos = self.rng.randint(0,len(data))
                if pos >= 0:
                    data = list(data)
                    data[pos] = corrupter_CM[data[pos]]
                    self.data, success = self.convert_back(data)
                    if success:
                        break
        if length_can_change and self.rng.uniform() < self.prob_e:
            # --- insertion error ---
            if self.debug:
                print('adding extra char')
            for _ in range(1+9*int(self.isTS)):

                data = self.data
                if self.isnumeric or self.isTS:
                    data = str(data)
                pos = -1
                for _ in range(5):
                    if pos > 0 and (data[pos] not in [' ', '.', ',']):
                        break
                    pos = self.rng.randint(0,len(data))
                if pos >=0:
                    if not(self.isalpha or self.isstrnumeric or self.isnumeric or self.isTS):
                        newchar = self.rng.choice(all_alpha_num)
                    elif self.isalpha:
                        newchar = self.rng.choice(all_alpha)
                    else:
                        newchar = self.rng.choice(all_num)
                    data = list(data)                
                    data = data[:pos] + [newchar] + data[pos:]
                    self.data, success = self.convert_back(data)
                    if success:
                        break
        if length_can_change and self.rng.uniform() < self.prob_e:
            # --- erasure error ---
            if self.debug:
                print('erasing a char')
            for _ in range(1+9*int(self.isTS)):
                data = self.data
                if self.isnumeric or self.isTS:
                    data = str(data)
                pos = -1
                for _ in range(5):
                    if pos > 0 and (data[pos] not in [' ', '.', ',',':','-']):
                        break
                    pos = self.rng.randint(0,len(data))
                if pos >= 0 and len(data) > 1: 
                    data = list(data)
                    if pos > 0:
                        data = data[:pos-1] + data[pos:]
                    else:
                        data = data[:pos] + data[pos+1:]
                    self.data, success = self.convert_back(data)
                    if success:
                        break
        return self.data            


class RecordCorrupter(object):
    """This class generates new records with some entries possibly
    corrupted. It uses an `EntryDataCorrupter` class to corrupt the
    data with a specified probability `prob_e`. The corrupted entries
    are determined based on whether they are corruptible or not. The
    class generates a `FormRecord` using the `FormDataType` class.

    Args:
        config (YmlConfig): A `YmlConfig` object containing the
             configuration information for the records.
        _type (TaxPayerType): An enumeration class that indicates
            the type of taxpayer that the records belong to.
            Defaults to TaxPayerType.individual
        corrupt_type (EntryDataCorrupter): A class that corrupts the
            data with a specified probability `prob_e`.
        rec_type (FormDataType): Type of form data. 
             Defaults to FormDataType.
        form_data_gen (Source): A generator that generates
             additional form data. Defaults to None.
        prob_e (float): The probability of data corruption.
            Defaults to 0.01.
        seed (int): A seed for the random number generator.
            Defaults to None.
        debug (int): A flag that indicates whether to print debug
             messages or not. Defaults to 0.

    Returns:
        If `as_df` is `True`, a `pandas` dataframe containing the
        new records is returned. Otherwise, a list of new records is
        returned.
    """
    
    def __init__(self, config:YmlConfig, _type=TaxPayerType.individual, 
            corrupt_type=EntryDataCorrupter, rec_type=FormDataType, form_data_gen=None,
            prob_e=0.01, seed=None, debug=0) -> None:
        
        assert _type in TaxPayerType, f'input {_type} is not a valid TaxPayerType'
        self._type = _type
        self.debug = debug
        self.rec_type = rec_type
        self.config = config
        self.seed = (np.random.randint(0,np.iinfo(np.int32).max) if seed is None else seed)
        self.rng = np.random.RandomState(seed=self.seed)
        rseed = lambda: self.rng.randint(0,np.iinfo(np.int32).max)
        if form_data_gen is None:
            self.form_data_gen = TaxFormData(config.get('form_name','unknown_form'), 
                rng=self.rng)
        else:
            assert isinstance(form_data_gen, Source), (
                'form data generator must be a "Source" type class')
            self.form_data_gen = form_data_gen
        self.record_corrupter = None
        # read in data and populate random generation objects
        if _type == TaxPayerType.individual:
            assert corrupt_type in [EntryDataCorrupter], f'invalid corrupter class type: {corrupt_type}'
            self.record_corrupter = corrupt_type(prob_e=prob_e,seed=rseed())
        else:
            raise NotImplementedError(f'{_type} is not currently implemented')

    def get_record(self, record:Record) -> FormRecord:
        """The get_record method generates a new record with some
        entries possibly corrupted. It uses EntryDataCorrupter class
        to corrupt the data with a specified probability prob_e. 
        The corrupted entries are determined based on whether they
        are corruptible or not. The method generates a FormRecord
        using the FormDataType class, which represents a data type
        for a form.

        Args:
        record (Record): An object of the Record class.

        Returns:
        FormRecord: A new record that has been possibly corrupted.
        """
        
        if self._type == TaxPayerType.individual:
            # reset whether document was HW or computer-inputted
            self.record_corrupter.reset_type()
            rec = FormRecord(datatype=self.rec_type, rng=self.rng, 
                **{k: (self.record_corrupter.get_sample(
                        v, length_can_change=(k in record._is_length_changable)) 
                    if (k in record._is_corruptible) else v)
                    for k,v in record.iteritems()})
            # add additional form data
            rec.update(self.form_data_gen.get_sample())
            return rec

    def corrupt_records(self,records: List or pd.DataFrame,
            incoming_default_record_type=Record,as_df=False
            ) -> tuple:
        """
        Corrupts the given records by generating new ones with
        corrupted data.

        Args:
            records (List[Record] or pd.DataFrame): List of Record
                objects or Pandas DataFrame with columns 
                representing Record attributes.
            incoming_default_record_type (Record): The type of
                Record to generate when creating corrupted records.
                Default is the same type as the input Record objects.
            as_df (bool): Whether to return the corrupted records as
                a Pandas DataFrame. Default is False.

        Returns:
            tuple: A tuple containing the corrupted records and a
                Pandas DataFrame if as_df is True.
            If records is a list of length 1, returns a single
                corrupted record. Otherwise, returns a list of
                corrupted records.
        """
        
        converter = ((lambda x: incoming_default_record_type(rng=self.rng,
            **{k: x[k] for k in x.keys()}))
            if isinstance(records,pd.DataFrame) else (lambda x: x))
        records = (records if isinstance(records, (pd.DataFrame,list)) else [records])
        _records = []
        if isinstance(records, pd.DataFrame):
            iterator = (tqdm(records.iterrows(),total=len(records),
                desc='Generating corrupted records (DF)') 
                if tqdm is not None and len(records) > 30 and self.debug else records.iterrows())
        else:
            iterator = (tqdm(enumerate(records),total=len(records),
                             desc='Generating corrupted records (list(dict))') 
                if tqdm is not None and len(records) > 30 and self.debug else enumerate(records))
        for _, element in iterator:
            _records.append(self.get_record(converter(element)))

        df = None
        if as_df:
            df = pd.DataFrame({k: [rec.__dict__[k] for rec in _records] 
                for k in _records[0]})
        if len(_records) == 1:
            return _records[0], df
        else:
            return _records, df

# ---------  corrupt and create alternative "documents" to performa matching against ---------
def gen_noisy_documents_from_records(
        data_config, recs=None, form_name=None, 
        prob_e=0.01, debug=0, as_df=False, overwrite=True, state='MD',
        write_to_db=False, seed=42, display=False, **kwargs):
    
    """Generates noisy documents from records using a
    RecordCorrupter object.

    Args:
        data_config (str or YmlConfig): Configuration file or
            YmlConfig object containing the data source details.
        recs (pd.DataFrame or list of Record objects, optional): 
            Records to use to generate noisy documents. 
            If not provided, records will be generated using
            gen_records_from_data() function. Defaults to None.
        form_name (str, optional): Name of the form. Defaults
            to None.
        prob_e (float, optional): Probability of an error in
            each field of the records. Defaults to 0.01.
        debug (int, optional): Debugging level. 0 for no
            debugging, higher values for more verbose output.
            Defaults to 0.
        as_df (bool, optional): Whether to return results as a
            pandas DataFrame. Defaults to False.
        overwrite (bool, optional): Whether to overwrite
            existing records. Defaults to True. If False, it
            will append the new data at the end.
        write_to_db (bool, optional): Whether to write results
            to a database. Defaults to False.
        seed (int, optional): Seed value for random number
            generation. Defaults to 42.
        display (bool, optional): Whether to display the
            resulting DataFrame. Defaults to False.
        **kwargs: Additional keyword arguments to pass to
            gen_records_from_data() function.

    Returns:
    pd.DataFrame or list of Record objects: Noisy documents
        generated from the records.
    YmlConfig: YmlConfig object containing the configuration used
        for generating the records.
    """

    if recs is None:
        recs, data_config = gen_records_from_data(data_config, 
            debug=max(0,debug-1), as_df=as_df,
            write_to_db=write_to_db, 
            overwrite=max(0,overwrite-1),
            seed=seed+1, state=state,
            # np.random.RandomState(seed=seed+1).randint(0,np.iinfo(np.int32).max), 
            display=display, **kwargs)

    if isinstance(data_config, YmlConfig):
        yml = data_config
    else:
        yml = YmlConfig(data_config,base_str='rec_gen', 
            auto_update_paths=True,debug=max(debug-1,0))
    debug and print(f'YML Configuration:\n{yml}')

    if form_name is None:
        assert ('form_name' in yml) and len(yml['form_name']), 'no form_name input or in config yml'
        form_name = yml['form_name']
    else:
        yml.setkeyvalue('form_name',form_name)

    rec_corrupter = RecordCorrupter(yml, prob_e=prob_e, seed=seed, debug=debug)
    
    recs_noisy, data = rec_corrupter.corrupt_records(recs, as_df=(as_df or write_to_db))

    if write_to_db:
        sqlcfg = SQLConfig(yml['dbconfig'], auto_update_paths=True)
        debug and print(f'SQL Configuration:\n{sqlcfg}')
        dbconn = DbConnectGenerator(config=sqlcfg)

        with dbconn.gen_connection(create_nonexist=True) as conn:
            conn.upload_df_to_table(data, form_name,
                if_exists=('replace' if overwrite else 'append'))
            debug and print(f'wrote form data to SQL table: {form_name}')
            
    elif display:
        print(data.head())

    if as_df:
        return data, yml
    else:
        return recs_noisy, yml


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='''
generate fake form and name data with deviations for matching algorithm dev

example call:
    python formsource.py --data-dir ./tests/ --add-unique-label --numrec 100000 --form-name irmf --write-to-db
''')
    parser.add_argument('--data-dir' ,'-d', dest='data_config', 
        nargs='?', required=False, default=None, 
        help='directory containing record generation config as well as name and street distributional data')
    parser.add_argument('--debug', '-v', nargs='?', type=int, required=False, const=1, 
        default=0, help='level of debug output printing')
    parser.add_argument('--seed', '-s', type=int, required=False, 
        default=None, help='seed for generating random data, default is None')
    parser.add_argument('--numrec', '-n', type=int, required=False, 
        default=5, help='number of records to generate, default is 5')
    parser.add_argument('--state', type=str, required=False, 
        default='MD', help='the state which is represented in the records, default is "MD"')
    parser.add_argument('--prob-error', '-p', type=float, required=False, 
        default=0.01, help='probability of inducing an error in the corrupted file entry, default is 0.01')
    parser.add_argument('--form-name', '-f', dest='form_name', type=str, required=False, 
        default=None, help='the name of the form for which to generate noisy record data')      
    parser.add_argument('--write-to-db', nargs='?', dest='write_to_db', 
        type=bool, const=True, default=False, required=False,
        help='whether to write to the DB, default is False')
    parser.add_argument('--overwrite', '-o', nargs='?', type=int, required=False, const=1, 
        default=0, help='overwrite existing records in DB (default is 0, which will append records)')
    parser.add_argument('--add-unique-label', '-l', nargs='?', dest='add_unique_label', 
        type=bool, required=False, const=True, default=False, help=('add unique id/label that '
        'cannot be corrupted, used for validating metrics on attempted matching'))
    
    args = parser.parse_args()
    if args.debug > 1:
        print("args:", args.__dict__)

    recs_noisy, df_noisy = gen_noisy_documents_from_records(display=True, **args.__dict__)

