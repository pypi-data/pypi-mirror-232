<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pytreegrav package &mdash; pytreegrav 0.27 documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pytreegrav
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="usage/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="usage/quickstart.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="Nbody_simulation.html">Example: N-body simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="frontend_API.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="community.html">Feedback, Support, and Contributions</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pytreegrav</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>pytreegrav package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/pytreegrav.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="pytreegrav-package">
<h1>pytreegrav package<a class="headerlink" href="#pytreegrav-package" title="Permalink to this headline"></a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline"></a></h2>
</div>
<div class="section" id="module-pytreegrav.bruteforce">
<span id="pytreegrav-bruteforce-module"></span><h2>pytreegrav.bruteforce module<a class="headerlink" href="#module-pytreegrav.bruteforce" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt id="pytreegrav.bruteforce.AccelTarget_bruteforce">
<code class="sig-prename descclassname">pytreegrav.bruteforce.</code><code class="sig-name descname">AccelTarget_bruteforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_target</span></em>, <em class="sig-param"><span class="n">softening_target</span></em>, <em class="sig-param"><span class="n">x_source</span></em>, <em class="sig-param"><span class="n">m_source</span></em>, <em class="sig-param"><span class="n">softening_source</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.bruteforce.AccelTarget_bruteforce" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational acceleration at a set of target positions, due to a set of source particles.</p>
<p>Arguments:
x_target – shape (N,3) array of positions where the field is to be evaluated
softening_target – shape (N,) array of minimum softening lengths to be used
x_source – shape (M,3) array of positions of gravitating particles
m_source – shape (M,) array of particle masses
softening_source – shape (M,) array of softening lengths</p>
<p>Optional arguments:
G – gravitational constant (default 1.0)</p>
<p>Returns:
shape (N,3) array of gravitational accelerations</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.bruteforce.AccelTarget_bruteforce_parallel">
<code class="sig-prename descclassname">pytreegrav.bruteforce.</code><code class="sig-name descname">AccelTarget_bruteforce_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_target</span></em>, <em class="sig-param"><span class="n">softening_target</span></em>, <em class="sig-param"><span class="n">x_source</span></em>, <em class="sig-param"><span class="n">m_source</span></em>, <em class="sig-param"><span class="n">softening_source</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.bruteforce.AccelTarget_bruteforce_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational acceleration at a set of target positions, due to a set of source particles.</p>
<p>Arguments:
x_target – shape (N,3) array of positions where the field is to be evaluated
softening_target – shape (N,) array of minimum softening lengths to be used
x_source – shape (M,3) array of positions of gravitating particles
m_source – shape (M,) array of particle masses
softening_source – shape (M,) array of softening lengths</p>
<p>Optional arguments:
G – gravitational constant (default 1.0)</p>
<p>Returns:
shape (N,3) array of gravitational accelerations</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.bruteforce.Accel_bruteforce">
<code class="sig-prename descclassname">pytreegrav.bruteforce.</code><code class="sig-name descname">Accel_bruteforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">softening</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.bruteforce.Accel_bruteforce" title="Permalink to this definition"></a></dt>
<dd><p>Returns the exact mutually-interacting gravitational accelerations of a set of particles.</p>
<p>Arguments:
x – shape (N,3) array of positions where the potential is to be evaluated
m – shape (N,) array of particle masses
softening – shape (N,) array of softening lengths</p>
<p>Optional arguments:
G – gravitational constant (default 1.0)</p>
<p>Returns:
shape (N,3) array of gravitational accelerations</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.bruteforce.Accel_bruteforce_parallel">
<code class="sig-prename descclassname">pytreegrav.bruteforce.</code><code class="sig-name descname">Accel_bruteforce_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">softening</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.bruteforce.Accel_bruteforce_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the exact mutually-interacting gravitational accelerations of a set of particles.</p>
<p>Arguments:
x – shape (N,3) array of positions where the potential is to be evaluated
m – shape (N,) array of particle masses
softening – shape (N,) array of softening lengths</p>
<p>Optional arguments:
G – gravitational constant (default 1.0)</p>
<p>Returns:
shape (N,3) array of gravitational accelerations</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.bruteforce.PotentialTarget_bruteforce">
<code class="sig-prename descclassname">pytreegrav.bruteforce.</code><code class="sig-name descname">PotentialTarget_bruteforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_target</span></em>, <em class="sig-param"><span class="n">softening_target</span></em>, <em class="sig-param"><span class="n">x_source</span></em>, <em class="sig-param"><span class="n">m_source</span></em>, <em class="sig-param"><span class="n">softening_source</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.bruteforce.PotentialTarget_bruteforce" title="Permalink to this definition"></a></dt>
<dd><p>Returns the exact gravitational potential due to a set of particles, at a set of positions that need not be the same as the particle positions.</p>
<p>Arguments:
x_target – shape (N,3) array of positions where the potential is to be evaluated
softening_target – shape (N,) array of minimum softening lengths to be used
x_source – shape (M,3) array of positions of gravitating particles
m_source – shape (M,) array of particle masses
softening_source – shape (M,) array of softening lengths</p>
<p>Optional arguments:
G – gravitational constant (default 0.7)</p>
<p>Returns:
shape (N,) array of potential values</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.bruteforce.PotentialTarget_bruteforce_parallel">
<code class="sig-prename descclassname">pytreegrav.bruteforce.</code><code class="sig-name descname">PotentialTarget_bruteforce_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x_target</span></em>, <em class="sig-param"><span class="n">softening_target</span></em>, <em class="sig-param"><span class="n">x_source</span></em>, <em class="sig-param"><span class="n">m_source</span></em>, <em class="sig-param"><span class="n">softening_source</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.bruteforce.PotentialTarget_bruteforce_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the exact gravitational potential due to a set of particles, at a set of positions that need not be the same as the particle positions.</p>
<p>Arguments:
x_target – shape (N,3) array of positions where the potential is to be evaluated
softening_target – shape (N,) array of minimum softening lengths to be used
x_source – shape (M,3) array of positions of gravitating particles
m_source – shape (M,) array of particle masses
softening_source – shape (M,) array of softening lengths</p>
<p>Optional arguments:
G – gravitational constant (default 0.7)</p>
<p>Returns:
shape (N,) array of potential values</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.bruteforce.Potential_bruteforce">
<code class="sig-prename descclassname">pytreegrav.bruteforce.</code><code class="sig-name descname">Potential_bruteforce</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">softening</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.bruteforce.Potential_bruteforce" title="Permalink to this definition"></a></dt>
<dd><p>Returns the exact mutually-interacting gravitational potential for a set of particles with positions x and masses m, evaluated by brute force.</p>
<p>Arguments:
x – shape (N,3) array of particle positions
m – shape (N,) array of particle masses
softening – shape (N,) array containing kernel support radii for gravitational softening</p>
<p>Optional arguments:
G – gravitational constant (default 1.0)</p>
<p>Returns:
shape (N,) array containing potential values</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.bruteforce.Potential_bruteforce_parallel">
<code class="sig-prename descclassname">pytreegrav.bruteforce.</code><code class="sig-name descname">Potential_bruteforce_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">softening</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.bruteforce.Potential_bruteforce_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the exact mutually-interacting gravitational potential for a set of particles with positions x and masses m, evaluated by brute force.</p>
<p>Arguments:
x – shape (N,3) array of particle positions
m – shape (N,) array of particle masses
softening – shape (N,) array containing kernel support radii for gravitational softening</p>
<p>Optional arguments:
G – gravitational constant (default 1.0)</p>
<p>Returns:
shape (N,) array containing potential values</p>
</dd></dl>

</div>
<div class="section" id="module-pytreegrav.dynamic_tree">
<span id="pytreegrav-dynamic-tree-module"></span><h2>pytreegrav.dynamic_tree module<a class="headerlink" href="#module-pytreegrav.dynamic_tree" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt id="pytreegrav.dynamic_tree.ComputeMomentsDynamic">
<code class="sig-prename descclassname">pytreegrav.dynamic_tree.</code><code class="sig-name descname">ComputeMomentsDynamic</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">no</span></em>, <em class="sig-param"><span class="n">children</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.dynamic_tree.ComputeMomentsDynamic" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pytreegrav.dynamic_tree.SetupTreewalk">
<code class="sig-prename descclassname">pytreegrav.dynamic_tree.</code><code class="sig-name descname">SetupTreewalk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">no</span></em>, <em class="sig-param"><span class="n">children</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.dynamic_tree.SetupTreewalk" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pytreegrav.frontend">
<span id="pytreegrav-frontend-module"></span><h2>pytreegrav.frontend module<a class="headerlink" href="#module-pytreegrav.frontend" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt id="pytreegrav.frontend.Accel">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">Accel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">softening</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'adaptive'</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.Accel" title="Permalink to this definition"></a></dt>
<dd><p>Gravitational acceleration calculation</p>
<p>Returns the gravitational acceleration for a set of particles with positions x and masses m, at the positions of those particles, using either brute force or tree-based methods depending on the number of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> (<em>array_like</em>) – shape (N,3) array of particle positions</p></li>
<li><p><strong>m</strong> (<em>array_like</em>) – shape (N,) array of particle masses</p></li>
<li><p><strong>G</strong> (<em>float</em><em>, </em><em>optional</em>) – gravitational constant (default 1.0)</p></li>
<li><p><strong>softening</strong> (<em>None</em><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – shape (N,) array containing kernel support radii for gravitational softening - these give the radius of compact support of the M4 cubic spline mass distribution - set to 0 by default</p></li>
<li><p><strong>theta</strong> (<em>float</em><em>, </em><em>optional</em>) – cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7, gives ~1% accuracy)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, will parallelize the force summation over all available cores. (default False)</p></li>
<li><p><strong>tree</strong> (<em>Octree</em><em>, </em><em>optional</em>) – optional pre-generated Octree: this can contain any set of particles, not necessarily the target particles at pos (default None)</p></li>
<li><p><strong>return_tree</strong> (<em>bool</em><em>, </em><em>optional</em>) – return the tree used for future use (default False)</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Which summation method to use: ‘adaptive’, ‘tree’, or ‘bruteforce’ (default adaptive tries to pick the faster choice)</p></li>
<li><p><strong>quadrupole</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use quadrupole moments in tree summation (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>g</strong> – shape (N,3) array of acceleration vectors at the particle positions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.AccelTarget">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">AccelTarget</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_target</span></em>, <em class="sig-param"><span class="n">pos_source</span></em>, <em class="sig-param"><span class="n">m_source</span></em>, <em class="sig-param"><span class="n">softening_target</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">softening_source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'adaptive'</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.AccelTarget" title="Permalink to this definition"></a></dt>
<dd><p>Gravitational acceleration calculation for general N+M body case</p>
<p>Returns the gravitational acceleration for a set of M particles with positions x_source and masses m_source, at the positions of a set of N particles that need not be the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos_target</strong> (<em>array_like</em>) – shape (N,3) array of target particle positions where you want to know the acceleration</p></li>
<li><p><strong>pos_source</strong> (<em>array_like</em>) – shape (M,3) array of source particle positions (positions of particles sourcing the gravitational field)</p></li>
<li><p><strong>m_source</strong> (<em>array_like</em>) – shape (M,) array of source particle masses</p></li>
<li><p><strong>softening_target</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – shape (N,) array of target particle softening radii - these give the radius of compact support of the M4 cubic spline mass distribution</p></li>
<li><p><strong>softening_source</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – shape (M,) array of source particle radii - these give the radius of compact support of the M4 cubic spline mass distribution</p></li>
<li><p><strong>G</strong> (<em>float</em><em>, </em><em>optional</em>) – gravitational constant (default 1.0)</p></li>
<li><p><strong>theta</strong> (<em>float</em><em>, </em><em>optional</em>) – cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7, gives ~1% accuracy)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, will parallelize the force summation over all available cores. (default False)</p></li>
<li><p><strong>tree</strong> (<em>Octree</em><em>, </em><em>optional</em>) – optional pre-generated Octree: this can contain any set of particles, not necessarily the target particles at pos (default None)</p></li>
<li><p><strong>return_tree</strong> (<em>bool</em><em>, </em><em>optional</em>) – return the tree used for future use (default False)</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Which summation method to use: ‘adaptive’, ‘tree’, or ‘bruteforce’ (default adaptive tries to pick the faster choice)</p></li>
<li><p><strong>quadrupole</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use quadrupole moments in tree summation (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>phi</strong> – shape (N,3) array of accelerations at the target positions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.ColumnDensity">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">ColumnDensity</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">radii</span></em>, <em class="sig-param"><span class="n">rays</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.ColumnDensity" title="Permalink to this definition"></a></dt>
<dd><p>Ray-traced column density calculation.</p>
<p>Returns the column density from the position of each particle integrated to
infinity, assuming the particles are represented by uniform spheres. Note
that optical depth can be obtained by supplying “σ = opacity * mass” in
place of mass, useful in situations where opacity is highly variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> (<em>array_like</em>) – shape (N,3) array of particle positions</p></li>
<li><p><strong>m</strong> (<em>array_like</em>) – shape (N,) array of particle masses</p></li>
<li><p><strong>radii</strong> (<em>array_like</em>) – shape (N,) array containing particle radii of the uniform spheres that
we use to model the particles’ mass distribution</p></li>
<li><p><strong>rays</strong> (<em>optional</em>) – Which ray directions to raytrace the columns. DEFAULT: The simple
6-ray grid.
OPTION 2: Give a (N_rays,3) array of vectors specifying the
directions, which will be automatically normalized.
OPTION 3: Give an integer number N to generate a raygrid of N random
directions.</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, will parallelize the column density over all available cores.
(default False)</p></li>
<li><p><strong>tree</strong> (<em>Octree</em><em>, </em><em>optional</em>) – optional pre-generated Octree: this can contain any set of particles,
not necessarily the target particles at pos (default None)</p></li>
<li><p><strong>return_tree</strong> (<em>bool</em><em>, </em><em>optional</em>) – return the tree used for future use (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>columns</strong> – shape (N,N_rays) float array of column densities from particle
centers integrated along the rays</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.ConstructTree">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">ConstructTree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">softening</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">vel</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.ConstructTree" title="Permalink to this definition"></a></dt>
<dd><p>Builds a tree containing particle data, for subsequent potential/field evaluation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> (<em>array_like</em>) – shape (N,3) array of particle positions</p></li>
<li><p><strong>m</strong> (<em>array_like</em>) – shape (N,) array of particle masses</p></li>
<li><p><strong>softening</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – shape (N,) array of particle softening lengths - these give the radius of compact support of the M4 cubic spline mass distribution of each particle</p></li>
<li><p><strong>quadrupole</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to store quadrupole moments (default False)</p></li>
<li><p><strong>vel</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to store node velocities in the tree (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tree</strong> – Octree instance built from particle data</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>octree</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.DensityCorrFunc">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">DensityCorrFunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">rbins</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.DensityCorrFunc" title="Permalink to this definition"></a></dt>
<dd><p>Computes the average amount of mass in radial bin [r,r+dr] around a point, provided a set of radial bins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> (<em>array_like</em>) – shape (N,3) array of particle positions</p></li>
<li><p><strong>m</strong> (<em>array_like</em>) – shape (N,) array of particle masses</p></li>
<li><p><strong>rbins</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – 1D array of radial bin edges - if None will use heuristics to determine sensible bins. Otherwise MUST BE LOGARITHMICALLY SPACED (default None)</p></li>
<li><p><strong>max_bin_size_ratio</strong> (<em>float</em><em>, </em><em>optional</em>) – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width (default 100)</p></li>
<li><p><strong>theta</strong> (<em>float</em><em>, </em><em>optional</em>) – cell opening angle used to control accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 1.0)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, will parallelize the correlation function computation over all available cores. (default False)</p></li>
<li><p><strong>tree</strong> (<em>Octree</em><em>, </em><em>optional</em>) – optional pre-generated Octree: this can contain any set of particles, not necessarily the target particles at pos (default None)</p></li>
<li><p><strong>return_tree</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True will return the generated or used tree for future use (default False)</p></li>
<li><p><strong>boxsize</strong> (<em>float</em><em>, </em><em>optional</em>) – finite periodic box size, if periodic boundary conditions are to be used (default 0)</p></li>
<li><p><strong>weighted_binning</strong> (<em>bool</em><em>, </em><em>optional</em>) – (experimental) if True will distribute mass among radial bings with a weighted kernel (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rbins</strong> (<em>array_like</em>) – array containing radial bin edges</p></li>
<li><p><strong>mbins</strong> (<em>array_like</em>) – array containing mean mass in radial bins, averaged over all points</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.Potential">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">Potential</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">softening</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'adaptive'</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.Potential" title="Permalink to this definition"></a></dt>
<dd><p>Gravitational potential calculation</p>
<p>Returns the gravitational potential for a set of particles with positions x and masses m, at the positions of those particles, using either brute force or tree-based methods depending on the number of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> (<em>array_like</em>) – shape (N,3) array of particle positions</p></li>
<li><p><strong>m</strong> (<em>array_like</em>) – shape (N,) array of particle masses</p></li>
<li><p><strong>G</strong> (<em>float</em><em>, </em><em>optional</em>) – gravitational constant (default 1.0)</p></li>
<li><p><strong>softening</strong> (<em>None</em><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – shape (N,) array containing kernel support radii for gravitational softening -  - these give the radius of compact support of the M4 cubic spline mass distribution - set to 0 by default</p></li>
<li><p><strong>theta</strong> (<em>float</em><em>, </em><em>optional</em>) – cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7, gives ~1% accuracy)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, will parallelize the force summation over all available cores. (default False)</p></li>
<li><p><strong>tree</strong> (<em>Octree</em><em>, </em><em>optional</em>) – optional pre-generated Octree: this can contain any set of particles, not necessarily the target particles at pos (default None)</p></li>
<li><p><strong>return_tree</strong> (<em>bool</em><em>, </em><em>optional</em>) – return the tree used for future use (default False)</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Which summation method to use: ‘adaptive’, ‘tree’, or ‘bruteforce’ (default adaptive tries to pick the faster choice)</p></li>
<li><p><strong>quadrupole</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use quadrupole moments in tree summation (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>phi</strong> – shape (N,) array of potentials at the particle positions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.PotentialTarget">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">PotentialTarget</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_target</span></em>, <em class="sig-param"><span class="n">pos_source</span></em>, <em class="sig-param"><span class="n">m_source</span></em>, <em class="sig-param"><span class="n">softening_target</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">softening_source</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'adaptive'</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.PotentialTarget" title="Permalink to this definition"></a></dt>
<dd><p>Gravitational potential calculation for general N+M body case</p>
<p>Returns the gravitational potential for a set of M particles with positions x_source and masses m_source, at the positions of a set of N particles that need not be the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos_target</strong> (<em>array_like</em>) – shape (N,3) array of target particle positions where you want to know the potential</p></li>
<li><p><strong>pos_source</strong> (<em>array_like</em>) – shape (M,3) array of source particle positions (positions of particles sourcing the gravitational field)</p></li>
<li><p><strong>m_source</strong> (<em>array_like</em>) – shape (M,) array of source particle masses</p></li>
<li><p><strong>softening_target</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – shape (N,) array of target particle softening radii - these give the radius of compact support of the M4 cubic spline mass distribution</p></li>
<li><p><strong>softening_source</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – shape (M,) array of source particle radii  - these give the radius of compact support of the M4 cubic spline mass distribution</p></li>
<li><p><strong>G</strong> (<em>float</em><em>, </em><em>optional</em>) – gravitational constant (default 1.0)</p></li>
<li><p><strong>theta</strong> (<em>float</em><em>, </em><em>optional</em>) – cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7, gives ~1% accuracy)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, will parallelize the force summation over all available cores. (default False)</p></li>
<li><p><strong>tree</strong> (<em>Octree</em><em>, </em><em>optional</em>) – optional pre-generated Octree: this can contain any set of particles, not necessarily the target particles at pos (default None)</p></li>
<li><p><strong>return_tree</strong> (<em>bool</em><em>, </em><em>optional</em>) – return the tree used for future use (default False)</p></li>
<li><p><strong>method</strong> (<em>str</em><em>, </em><em>optional</em>) – Which summation method to use: ‘adaptive’, ‘tree’, or ‘bruteforce’ (default adaptive tries to pick the faster choice)</p></li>
<li><p><strong>quadrupole</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use quadrupole moments in tree summation (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>phi</strong> – shape (N,) array of potentials at the target positions</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array_like</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.VelocityCorrFunc">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">VelocityCorrFunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">rbins</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.VelocityCorrFunc" title="Permalink to this definition"></a></dt>
<dd><p>Computes the weighted average product v(x).v(x+r), for a vector field v, in radial bins</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> (<em>array_like</em>) – shape (N,3) array of particle positions</p></li>
<li><p><strong>m</strong> (<em>array_like</em>) – shape (N,) array of particle masses</p></li>
<li><p><strong>v</strong> (<em>array_like</em>) – shape (N,3) of vector quantity (e.g. velocity, magnetic field, etc)</p></li>
<li><p><strong>rbins</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – 1D array of radial bin edges - if None will use heuristics to determine sensible bins. Otherwise MUST BE LOGARITHMICALLY SPACED (default None)</p></li>
<li><p><strong>max_bin_size_ratio</strong> (<em>float</em><em>, </em><em>optional</em>) – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width (default 100)</p></li>
<li><p><strong>theta</strong> (<em>float</em><em>, </em><em>optional</em>) – cell opening angle used to control accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 1.0)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, will parallelize the correlation function computation over all available cores. (default False)</p></li>
<li><p><strong>tree</strong> (<em>Octree</em><em>, </em><em>optional</em>) – optional pre-generated Octree: this can contain any set of particles, not necessarily the target particles at pos (default None)</p></li>
<li><p><strong>return_tree</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True will return the generated or used tree for future use (default False)</p></li>
<li><p><strong>boxsize</strong> (<em>float</em><em>, </em><em>optional</em>) – finite periodic box size, if periodic boundary conditions are to be used (default 0)</p></li>
<li><p><strong>weighted_binning</strong> (<em>bool</em><em>, </em><em>optional</em>) – (experimental) if True will distribute mass among radial bings with a weighted kernel (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rbins</strong> (<em>array_like</em>) – array containing radial bin edges</p></li>
<li><p><strong>corr</strong> (<em>array_like</em>) – array containing correlation function values in radial bins</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.VelocityStructFunc">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">VelocityStructFunc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">m</span></em>, <em class="sig-param"><span class="n">v</span></em>, <em class="sig-param"><span class="n">rbins</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">tree</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_tree</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">parallel</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.VelocityStructFunc" title="Permalink to this definition"></a></dt>
<dd><p>Computes the structure function for a vector field: the average value of <a href="#id1"><span class="problematic" id="id2">|</span></a>v(x)-v(x+r)|^2, in radial bins for r</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pos</strong> (<em>array_like</em>) – shape (N,3) array of particle positions</p></li>
<li><p><strong>m</strong> (<em>array_like</em>) – shape (N,) array of particle masses</p></li>
<li><p><strong>v</strong> (<em>array_like</em>) – shape (N,3) of vector quantity (e.g. velocity, magnetic field, etc)</p></li>
<li><p><strong>rbins</strong> (<em>array_like</em><em> or </em><em>None</em><em>, </em><em>optional</em>) – 1D array of radial bin edges - if None will use heuristics to determine sensible bins. Otherwise MUST BE LOGARITHMICALLY SPACED (default None)</p></li>
<li><p><strong>max_bin_size_ratio</strong> (<em>float</em><em>, </em><em>optional</em>) – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width (default 100)</p></li>
<li><p><strong>theta</strong> (<em>float</em><em>, </em><em>optional</em>) – cell opening angle used to control accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 1.0)</p></li>
<li><p><strong>parallel</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, will parallelize the correlation function computation over all available cores. (default False)</p></li>
<li><p><strong>tree</strong> (<em>Octree</em><em>, </em><em>optional</em>) – optional pre-generated Octree: this can contain any set of particles, not necessarily the target particles at pos (default None)</p></li>
<li><p><strong>return_tree</strong> (<em>bool</em><em>, </em><em>optional</em>) – if True will return the generated or used tree for future use (default False)</p></li>
<li><p><strong>boxsize</strong> (<em>float</em><em>, </em><em>optional</em>) – finite periodic box size, if periodic boundary conditions are to be used (default 0)</p></li>
<li><p><strong>weighted_binning</strong> (<em>bool</em><em>, </em><em>optional</em>) – (experimental) if True will distribute mass among radial bings with a weighted kernel (default False)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rbins</strong> (<em>array_like</em>) – array containing radial bin edges</p></li>
<li><p><strong>Sv</strong> (<em>array_like</em>) – array containing structure function values</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.frontend.valueTestMethod">
<code class="sig-prename descclassname">pytreegrav.frontend.</code><code class="sig-name descname">valueTestMethod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">method</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.frontend.valueTestMethod" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pytreegrav.kernel">
<span id="pytreegrav-kernel-module"></span><h2>pytreegrav.kernel module<a class="headerlink" href="#module-pytreegrav.kernel" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt id="pytreegrav.kernel.ForceKernel">
<code class="sig-prename descclassname">pytreegrav.kernel.</code><code class="sig-name descname">ForceKernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">h</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.kernel.ForceKernel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the quantity equivalent to (fraction of mass enclosed)/ r^3 for a cubic-spline mass distribution of compact support radius h. Used to calculate the softened gravitational force.</p>
<p>Arguments:
r - radius
h - softening</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.kernel.PotentialKernel">
<code class="sig-prename descclassname">pytreegrav.kernel.</code><code class="sig-name descname">PotentialKernel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">h</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.kernel.PotentialKernel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the equivalent of -1/r for a cubic-spline mass distribution of compact support radius h. Used to calculate the softened gravitational potential.</p>
<p>Arguments:
r - radius
h - softening</p>
</dd></dl>

</div>
<div class="section" id="module-pytreegrav.octree">
<span id="pytreegrav-octree-module"></span><h2>pytreegrav.octree module<a class="headerlink" href="#module-pytreegrav.octree" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt id="pytreegrav.octree.ComputeMoments">
<code class="sig-prename descclassname">pytreegrav.octree.</code><code class="sig-name descname">ComputeMoments</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">no</span></em>, <em class="sig-param"><span class="n">children</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.octree.ComputeMoments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pytreegrav.octree.SetupTreewalk">
<code class="sig-prename descclassname">pytreegrav.octree.</code><code class="sig-name descname">SetupTreewalk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">no</span></em>, <em class="sig-param"><span class="n">children</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.octree.SetupTreewalk" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pytreegrav.treewalk">
<span id="pytreegrav-treewalk-module"></span><h2>pytreegrav.treewalk module<a class="headerlink" href="#module-pytreegrav.treewalk" title="Permalink to this headline"></a></h2>
<dl class="py function">
<dt id="pytreegrav.treewalk.AccelTarget_tree">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">AccelTarget_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_target</span></em>, <em class="sig-param"><span class="n">softening_target</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.AccelTarget_tree" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational acceleration at the specified points, given a tree containing the mass distribution
Arguments:
pos_target – shape (N,3) array of positions at which to evaluate the field
softening_target – shape (N,) array of <em>minimum</em> softening lengths to be used in all accel computations
tree – Octree instance containing the positions, masses, and softenings of the source particles
Optional arguments:
G – gravitational constant (default 1.0)
theta – accuracy parameter, smaller is more accurate, larger is faster (default 0.7)
Returns:
shape (N,3) array of acceleration values at each point in pos_target</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.AccelTarget_tree_parallel">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">AccelTarget_tree_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_target</span></em>, <em class="sig-param"><span class="n">softening_target</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.AccelTarget_tree_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational acceleration at the specified points, given a tree containing the mass distribution
Arguments:
pos_target – shape (N,3) array of positions at which to evaluate the field
softening_target – shape (N,) array of <em>minimum</em> softening lengths to be used in all accel computations
tree – Octree instance containing the positions, masses, and softenings of the source particles
Optional arguments:
G – gravitational constant (default 1.0)
theta – accuracy parameter, smaller is more accurate, larger is faster (default 0.7)
Returns:
shape (N,3) array of acceleration values at each point in pos_target</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.AccelWalk">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">AccelWalk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">softening</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">no</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.AccelWalk" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational acceleration field at position x by performing the Barnes-Hut treewalk using the provided octree instance
Arguments:
pos - (3,) array containing position of interest
tree - octree instance storing the tree structure
Keyword arguments:
softening - softening radius of the particle at which the force is being evaluated - we use the greater of the target and source softenings when evaluating the softened potential
no - index of the top-level node whose field is being summed - defaults to the global top-level node, can use a subnode in principle for e.g. parallelization
theta - cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7 gives ~1% accuracy)</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.AccelWalk_quad">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">AccelWalk_quad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">softening</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">no</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.AccelWalk_quad" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational acceleration field at position x by performing the Barnes-Hut treewalk using the provided octree instance. Uses the quadrupole expansion.
Arguments:
pos - (3,) array containing position of interest
tree - octree instance storing the tree structure
Keyword arguments:
softening - softening radius of the particle at which the force is being evaluated - we use the greater of the target and source softenings when evaluating the softened potential
no - index of the top-level node whose field is being summed - defaults to the global top-level node, can use a subnode in principle for e.g. parallelization
theta - cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7 gives ~1% accuracy)</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.ColumnDensityWalk">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">ColumnDensityWalk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">rays</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">no</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.ColumnDensityWalk" title="Permalink to this definition"></a></dt>
<dd><p>Returns the integrated column density to infinity from pos, in the directions given by the rays argument</p>
<p>Arguments:
pos - (3,) array containing position of interest
rays - (N_rays, 3) array of unit vectors
tree - octree object storing the tree structure</p>
<p>Returns:
columns - (N_rays,) array of column densities along directions given by rays</p>
<p>Keyword arguments:
no - index of the top-level node whose field is being summed - defaults to the global top-level node, can use a subnode in principle for e.g. parallelization</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.ColumnDensity_tree">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">ColumnDensity_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_target</span></em>, <em class="sig-param"><span class="n">rays</span></em>, <em class="sig-param"><span class="n">tree</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.ColumnDensity_tree" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at the specified points, given a
tree containing the mass distribution
Arguments:
pos_target – shape (N,3) array of positions at which to evaluate the
potential
tree – Octree instance containing the positions, masses, and softenings of
the source particles</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.ColumnDensity_tree_parallel">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">ColumnDensity_tree_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_target</span></em>, <em class="sig-param"><span class="n">rays</span></em>, <em class="sig-param"><span class="n">tree</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.ColumnDensity_tree_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at the specified points, given a
tree containing the mass distribution
Arguments:
pos_target – shape (N,3) array of positions at which to evaluate the
potential
tree – Octree instance containing the positions, masses, and softenings of
the source particles</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.DensityCorrFunc_tree">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">DensityCorrFunc_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.DensityCorrFunc_tree" title="Permalink to this definition"></a></dt>
<dd><p>Returns the average mass in radial bins surrounding a point</p>
<p>Arguments:
pos – shape (N,3) array of particle positions
tree – Octree instance containing the positions, masses, and softenings of the source particles</p>
<p>Optional arguments:
rbins – 1D array of radial bin edges - if None will use heuristics to determine sensible bins
max_bin_size_ratio – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width</p>
<p>Returns:
mbins – arrays containing total mass in each bin</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.DensityCorrFunc_tree_parallel">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">DensityCorrFunc_tree_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.DensityCorrFunc_tree_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the average mass in radial bins surrounding a point</p>
<p>Arguments:
pos – shape (N,3) array of particle positions
tree – Octree instance containing the positions, masses, and softenings of the source particles</p>
<p>Optional arguments:
rbins – 1D array of radial bin edges - if None will use heuristics to determine sensible bins
max_bin_size_ratio – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width</p>
<p>Returns:
mbins – arrays containing total mass in each bin</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.DensityCorrWalk">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">DensityCorrWalk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">no</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.DensityCorrWalk" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at position x by performing the Barnes-Hut treewalk using the provided octree instance</p>
<p>Arguments:
pos - (3,) array containing position of interest
tree - octree object storing the tree structure</p>
<p>Keyword arguments:
softening - softening radius of the particle at which the force is being evaluated - we use the greater of the target and source softenings when evaluating the softened potential
no - index of the top-level node whose field is being summed - defaults to the global top-level node, can use a subnode in principle for e.g. parallelization
theta - cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7 gives ~1% accuracy)</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.NearestImage">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">NearestImage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">x</span></em>, <em class="sig-param"><span class="n">boxsize</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.NearestImage" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.PotentialTarget_tree">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">PotentialTarget_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_target</span></em>, <em class="sig-param"><span class="n">softening_target</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.PotentialTarget_tree" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at the specified points, given a tree containing the mass distribution
Arguments:
pos_target – shape (N,3) array of positions at which to evaluate the potential
softening_target – shape (N,) array of <em>minimum</em> softening lengths to be used in all potential computations
tree – Octree instance containing the positions, masses, and softenings of the source particles
Optional arguments:
G – gravitational constant (default 1.0)
theta – accuracy parameter, smaller is more accurate, larger is faster (default 0.7)
Returns:
shape (N,) array of potential values at each point in pos</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.PotentialTarget_tree_parallel">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">PotentialTarget_tree_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos_target</span></em>, <em class="sig-param"><span class="n">softening_target</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">G</span><span class="o">=</span><span class="default_value">1.0</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">quadrupole</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.PotentialTarget_tree_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at the specified points, given a tree containing the mass distribution
Arguments:
pos_target – shape (N,3) array of positions at which to evaluate the potential
softening_target – shape (N,) array of <em>minimum</em> softening lengths to be used in all potential computations
tree – Octree instance containing the positions, masses, and softenings of the source particles
Optional arguments:
G – gravitational constant (default 1.0)
theta – accuracy parameter, smaller is more accurate, larger is faster (default 0.7)
Returns:
shape (N,) array of potential values at each point in pos</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.PotentialWalk">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">PotentialWalk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">softening</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">no</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.PotentialWalk" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at position x by performing the Barnes-Hut treewalk using the provided octree instance
Arguments:
pos - (3,) array containing position of interest
tree - octree object storing the tree structure
Keyword arguments:
softening - softening radius of the particle at which the force is being evaluated - we use the greater of the target and source softenings when evaluating the softened potential
no - index of the top-level node whose field is being summed - defaults to the global top-level node, can use a subnode in principle for e.g. parallelization
theta - cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7 gives ~1% accuracy)</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.PotentialWalk_quad">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">PotentialWalk_quad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">softening</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">no</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.PotentialWalk_quad" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at position x by performing the Barnes-Hut treewalk using the provided octree instance. Uses the quadrupole expansion.
Arguments:
pos - (3,) array containing position of interest
tree - octree object storing the tree structure
Keyword arguments:
softening - softening radius of the particle at which the force is being evaluated - we use the greater of the target and source softenings when evaluating the softened potential
no - index of the top-level node whose field is being summed - defaults to the global top-level node, can use a subnode in principle for e.g. parallelization
theta - cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7 gives ~1% accuracy)</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.VelocityCorrFunc_tree">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">VelocityCorrFunc_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">vel</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.VelocityCorrFunc_tree" title="Permalink to this definition"></a></dt>
<dd><p>Returns the average mass in radial bins surrounding a point</p>
<p>Arguments:
pos – shape (N,3) array of particle positions
tree – Octree instance containing the positions, masses, and softenings of the source particles</p>
<p>Optional arguments:
rbins – 1D array of radial bin edges - if None will use heuristics to determine sensible bins
max_bin_size_ratio – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width (default 0.5)</p>
<p>Returns:
mbins – arrays containing total mass in each bin</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.VelocityCorrFunc_tree_parallel">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">VelocityCorrFunc_tree_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">vel</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.VelocityCorrFunc_tree_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the average mass in radial bins surrounding a point</p>
<p>Arguments:
pos – shape (N,3) array of particle positions
tree – Octree instance containing the positions, masses, and softenings of the source particles</p>
<p>Optional arguments:
rbins – 1D array of radial bin edges - if None will use heuristics to determine sensible bins
max_bin_size_ratio – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width (default 0.5)</p>
<p>Returns:
mbins – arrays containing total mass in each bin</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.VelocityCorrWalk">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">VelocityCorrWalk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">vel</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">no</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.VelocityCorrWalk" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at position x by performing the Barnes-Hut treewalk using the provided octree instance</p>
<p>Arguments:
pos - (3,) array containing position of interest
vel - (3,) array containing velocity of point of interest
tree - octree object storing the tree structure</p>
<p>Keyword arguments:
softening - softening radius of the particle at which the force is being evaluated - we use the greater of the target and source softenings when evaluating the softened potential
no - index of the top-level node whose field is being summed - defaults to the global top-level node, can use a subnode in principle for e.g. parallelization
theta - cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7 gives ~1% accuracy)</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.VelocityStructFunc_tree">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">VelocityStructFunc_tree</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">vel</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.VelocityStructFunc_tree" title="Permalink to this definition"></a></dt>
<dd><p>Returns the average mass in radial bins surrounding a point</p>
<p>Arguments:
pos – shape (N,3) array of particle positions
tree – Octree instance containing the positions, masses, and softenings of the source particles</p>
<p>Optional arguments:
rbins – 1D array of radial bin edges - if None will use heuristics to determine sensible bins
max_bin_size_ratio – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width (default 0.5)</p>
<p>Returns:
mbins – arrays containing total mass in each bin</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.VelocityStructFunc_tree_parallel">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">VelocityStructFunc_tree_parallel</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">vel</span></em>, <em class="sig-param"><span class="n">weight</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.VelocityStructFunc_tree_parallel" title="Permalink to this definition"></a></dt>
<dd><p>Returns the average mass in radial bins surrounding a point</p>
<p>Arguments:
pos – shape (N,3) array of particle positions
tree – Octree instance containing the positions, masses, and softenings of the source particles</p>
<p>Optional arguments:
rbins – 1D array of radial bin edges - if None will use heuristics to determine sensible bins
max_bin_size_ratio – controls the accuracy of the binning - tree nodes are subdivided until their side length is at most this factor * the radial bin width (default 0.5)</p>
<p>Returns:
mbins – arrays containing total mass in each bin</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.VelocityStructWalk">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">VelocityStructWalk</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pos</span></em>, <em class="sig-param"><span class="n">vel</span></em>, <em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">max_bin_size_ratio</span><span class="o">=</span><span class="default_value">100</span></em>, <em class="sig-param"><span class="n">theta</span><span class="o">=</span><span class="default_value">0.7</span></em>, <em class="sig-param"><span class="n">no</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">boxsize</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">weighted_binning</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.VelocityStructWalk" title="Permalink to this definition"></a></dt>
<dd><p>Returns the gravitational potential at position x by performing the Barnes-Hut treewalk using the provided octree instance</p>
<p>Arguments:
pos - (3,) array containing position of interest
vel - (3,) array containing velocity of point of interest
tree - octree object storing the tree structure</p>
<p>Keyword arguments:
softening - softening radius of the particle at which the force is being evaluated - we use the greater of the target and source softenings when evaluating the softened potential
no - index of the top-level node whose field is being summed - defaults to the global top-level node, can use a subnode in principle for e.g. parallelization
theta - cell opening angle used to control force accuracy; smaller is slower (runtime ~ theta^-3) but more accurate. (default 0.7 gives ~1% accuracy)</p>
</dd></dl>

<dl class="py function">
<dt id="pytreegrav.treewalk.do_weighted_binning">
<code class="sig-prename descclassname">pytreegrav.treewalk.</code><code class="sig-name descname">do_weighted_binning</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">tree</span></em>, <em class="sig-param"><span class="n">no</span></em>, <em class="sig-param"><span class="n">rbins</span></em>, <em class="sig-param"><span class="n">mbin</span></em>, <em class="sig-param"><span class="n">r</span></em>, <em class="sig-param"><span class="n">r_idx</span></em>, <em class="sig-param"><span class="n">quantity</span></em><span class="sig-paren">)</span><a class="headerlink" href="#pytreegrav.treewalk.do_weighted_binning" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pytreegrav">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pytreegrav" title="Permalink to this headline"></a></h2>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Mike Grudic.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>